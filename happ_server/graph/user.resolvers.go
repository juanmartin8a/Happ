package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.31

import (
	"bytes"
	"context"
	"encoding/base64"
	"encoding/json"
	"fmt"
	"happ/config"
	"happ/ent"
	"happ/ent/device"
	"happ/ent/event"
	"happ/ent/eventuser"
	"happ/ent/follow"
	"happ/ent/schema/schematype"
	"happ/ent/user"
	"happ/graph/dataloaders"
	"happ/graph/generated"
	"happ/graph/model"
	"happ/utils"
	AES_Encryption "happ/utils/AES-GCM_Encryption"
	awsParameterStore "happ/utils/aws/awsParams"
	"happ/utils/aws/awsS3"
	firebaseUtils "happ/utils/firebase"
	googleMapsUtils "happ/utils/googleMaps"
	"happ/utils/inputHandlers"
	meilisearchUtils "happ/utils/meilisearch"
	"happ/utils/newEventUtils"
	"happ/utils/notifications"
	"io"
	"log"
	"math/rand"
	"strconv"
	"strings"
	"time"

	"github.com/google/uuid"
)

// EventDate is the resolver for the eventDate field.
func (r *eventResolver) EventDate(ctx context.Context, obj *ent.Event) (string, error) {
	EventDateNano := obj.EventDate.UnixNano()

	EventDatemillis := EventDateNano / 1000000

	EventDateTime := int(EventDatemillis)

	EventDate := strconv.Itoa(EventDateTime)

	return EventDate, nil
}

// CreatedAt is the resolver for the createdAt field.
func (r *eventResolver) CreatedAt(ctx context.Context, obj *ent.Event) (string, error) {
	createdAtNano := obj.CreatedAt.UnixNano()

	createdAtmillis := createdAtNano / 1000000

	createdAtTime := int(createdAtmillis)

	createdAt := strconv.Itoa(createdAtTime)

	return createdAt, nil
}

// UpdatedAt is the resolver for the updatedAt field.
func (r *eventResolver) UpdatedAt(ctx context.Context, obj *ent.Event) (string, error) {
	updatedAtNano := obj.UpdatedAt.UnixNano()

	updatedAtmillis := updatedAtNano / 1000000

	updatedAtTime := int(updatedAtmillis)

	updatedAt := strconv.Itoa(updatedAtTime)

	return updatedAt, nil
}

// Coords is the resolver for the coords field.
func (r *eventResolver) Coords(ctx context.Context, obj *ent.Event) (*model.Coordinates, error) {
	return &model.Coordinates{
		Latitude:  obj.Coords[0],
		Longitude: obj.Coords[1],
	}, nil
}

// InvitedBy is the resolver for the invitedBy field.
func (r *eventInviteResResolver) InvitedBy(ctx context.Context, obj *model.EventInviteRes) (*ent.User, error) {
	return dataloaders.GetUser(ctx, strconv.Itoa(obj.InvitedByUserID))
}

// Friends is the resolver for the friends field.
func (r *eventInviteResResolver) Friends(ctx context.Context, obj *model.EventInviteRes) ([]*ent.User, error) {
	var users []*ent.User
	_, err := utils.GetUserIdFromHeader(ctx)
	if err != nil {
		return users, nil
	}

	return dataloaders.GetFriends(ctx, strconv.Itoa(obj.Event.ID))

	// QUERY MADE BY CHAT GPT
	// res, err := r.client.QueryContext(ctx, `
	// 	SELECT u.*, f.user_id FROM users u

	// 	INNER JOIN event_users eu ON eu.user_id = u.id
	// 	LEFT JOIN follows f ON f.user_id = u.id AND f.follower_id = `+strconv.Itoa(*userId)+` AND f.valid = true

	// 	WHERE eu.event_id = `+strconv.Itoa(obj.Event.ID)+` AND eu.confirmed = true

	// 	ORDER BY CASE WHEN f.user_id = `+strconv.Itoa(*userId)+` THEN 1 ELSE 2 END, f.user_id DESC

	// 	LIMIT 3;
	// `)
	// if err != nil {
	// 	return users, nil
	// }

	// for res.Next() {
	// 	var id int
	// 	var name string
	// 	var username string
	// 	var email string
	// 	var fuid string
	// 	// var birthday time.Time
	// 	// var password string
	// 	var created_at time.Time
	// 	var updated_at time.Time
	// 	var profile_pic string
	// 	var user_id *int

	// 	if err := res.Scan(
	// 		&id,
	// 		&name,
	// 		&username,
	// 		&email,
	// 		// &birthday,
	// 		// &password,
	// 		&created_at,
	// 		&updated_at,
	// 		&profile_pic,
	// 		&fuid,
	// 		&user_id,
	// 	); err != nil {
	// 		// Check for a scan error.
	// 		log.Println(err)
	// 		var emptyUsersSlice []*ent.User
	// 		return emptyUsersSlice, err
	// 	}

	// 	event := ent.User{
	// 		ID:         id,
	// 		Name:       name,
	// 		Username:   username,
	// 		Email:      email,
	// 		CreatedAt:  created_at,
	// 		UpdatedAt:  updated_at,
	// 		ProfilePic: profile_pic,
	// 		FUID:       fuid,
	// 	}

	// 	// events = append(events, &event)
	// 	users = append(users, &event)
	// }

	// res.Close()

	// return users, nil
}

// SignIn is the resolver for the signIn field.
func (r *mutationResolver) SignIn(ctx context.Context, input model.SignInInput) (*model.SignInResponse, error) {
	// Verify token
	token, err := firebaseUtils.AuthClient.VerifyIDToken(ctx, input.Token)
	if err != nil {
		return nil, fmt.Errorf("error verifying id token: %v", err)
	}

	var exists bool

	userToSign, err := r.client.User.Query().
		Where(
			user.FUID(token.UID),
		).
		Only(ctx)
	if err != nil {
		// exists = false
		if ent.IsNotFound(err) {
			exists = false
		} else {
			return nil, fmt.Errorf("error querying user: %v", err)
		}
	} else {
		exists = true
	}

	if exists {
		value := false
		return &model.SignInResponse{
			User:  userToSign,
			IsNew: &value,
		}, nil
	}

	var name string

	var username string

	var authCode *string

	if token.Claims["name"] != nil {

		name = token.Claims["name"].(string)
		if len(name) > 30 {
			name = name[:30]
		}

		preUsername := inputHandlers.ProcessString(name)

		if len(preUsername) > 30 {
			preUsername = preUsername[:30]
		}

		username = preUsername

	} else {

		if input.Provider == "APPLE" {
			name = input.AppleData.Name
			if len(name) > 30 {
				name = name[:30]
			}

			// preUsername := strings.ToLower(strings.ReplaceAll(name, " ", ""))

			// reg := regexp.MustCompile("[^a-z0-9.]")
			// preUsername = reg.ReplaceAllString(name, "")
			preUsername := inputHandlers.ProcessString(name)

			if len(preUsername) > 30 {
				preUsername = preUsername[:30]
			}

			username = preUsername
		} else {
			rand.Seed(time.Now().UnixNano())
			randomNumber := rand.Int63n(900000000000) + 100000000000

			username = "user" + strconv.FormatInt(randomNumber, 10)
			name = username
		}

	}

	email := token.Claims["email"].(string)

	picture, ok := token.Claims["picture"].(string)
	if !ok {
		if config.C.AppEnv == "prod" {
			picture = "https://di7aab2ls1mmt.cloudfront.net/userProfilePics/blueLobster.jpg"
		} else if config.C.AppEnv == "dev" {
			picture = "https://d3pvchlba3rmqp.cloudfront.net/userProfilePics/blueLobster.jpg"
		}
	}

	newUser, err := r.client.User.Create().
		SetFUID(token.UID).
		SetName(name).
		SetUsername(username).
		SetEmail(email).
		SetProfilePic(picture).
		Save(ctx)
	if err != nil {
		if ent.IsConstraintError(err) {
			rand.Seed(time.Now().UnixNano())
			randomNumber := rand.Int63n(900000000000) + 100000000000

			username = "user" + strconv.FormatInt(randomNumber, 10)

			newUser, err = r.client.User.Create().
				SetFUID(token.UID).
				SetName(name).
				SetUsername(username).
				SetEmail(email).
				SetProfilePic(picture).
				Save(ctx)
			if err != nil {
				return nil, fmt.Errorf("could not create user")
			}

		} else {
			return nil, fmt.Errorf("could not create user")
		}
	}

	rollback := false
	rollbackMeilisearchUserToo := false
	defer func() {
		if rollback {
			_, err := r.client.User.Delete().Where(user.ID(newUser.ID)).Exec(ctx)
			if err != nil {
				log.Printf("Failed to delete user after custom claims error: %v\n", err)
			}

			if rollbackMeilisearchUserToo {
				ok := meilisearchUtils.RemoveUserFromMeili(newUser.ID)
				if !ok {
					log.Printf("Failed to delete user from meilisearch: %v\n", err)
				}
			}
		}
	}()

	res := meilisearchUtils.AddUserToMeili(newUser)
	if !res {
		rollback = true
		return nil, fmt.Errorf("error creating meilisearch user: %v", err)
	}

	if input.Provider == "APPLE" {
		authCode = &input.AppleData.AuthorizationCode
	}

	claims := map[string]interface{}{
		"id":                     newUser.ID,
		"picture":                picture,
		"username":               username,
		"name":                   name,
		"appleAuthorizationCode": authCode,
	}
	err = firebaseUtils.AuthClient.SetCustomUserClaims(ctx, token.UID, claims)
	if err != nil {
		rollbackMeilisearchUserToo = true
		rollback = true
		return nil, fmt.Errorf("error setting custom claims: %v", err)
	}

	value := true

	return &model.SignInResponse{
		User:  newUser,
		IsNew: &value,
	}, nil
}

// DeleteUser is the resolver for the deleteUser field.
func (r *mutationResolver) DeleteUser(ctx context.Context) (bool, error) {
	userIdAndFUID, authErr := utils.IsAuthWithFUID(ctx)
	if authErr != nil {
		return false, authErr
	}

	userId := userIdAndFUID.UserId
	firebaseUID := userIdAndFUID.FirebaseUID

	type EventToCancel struct {
		EventID   int
		EventName string
	}

	type EventToUpdate struct {
		EventName        string
		EventAdminTokens []string
	}

	var eventsToCancel []EventToCancel
	var eventsToUpdate []EventToUpdate

	var keysFromS3ToDelete []string

	tx, err := r.client.Tx(ctx)
	if err != nil {
		return false, err
	}

	eventUsers, err := tx.EventUser.Query().
		Where(
			eventuser.And(
				eventuser.UserID(*userId),
				eventuser.Confirmed(true),
			),
		).
		All(ctx)
	if err != nil {
		if rerr := tx.Rollback(); rerr != nil {
			err = fmt.Errorf("%w: %v", err, rerr)
			return false, err
		}
	}

	if len(eventUsers) > 0 {
		var eventIdsWhereGuest []int
		var eventIdsWhereHost []int
		var eventIdsWhereCreator []int
		for _, eventUser := range eventUsers {
			if eventUser.Admin {
				eventIdsWhereHost = append(eventIdsWhereHost, eventUser.EventID)
				if eventUser.Creator {
					eventIdsWhereCreator = append(eventIdsWhereCreator, eventUser.EventID)
				}
			} else {
				eventIdsWhereGuest = append(eventIdsWhereGuest, eventUser.EventID)
			}
		}

		if len(eventIdsWhereGuest) > 0 {
			_, err = tx.Event.Update().
				Where(event.IDIn(eventIdsWhereGuest...)).
				AddConfirmedCount(-1).
				Save(ctx)
			if err != nil {
				log.Printf("error while updating event: %s", err)
				if rerr := tx.Rollback(); rerr != nil {
					err = fmt.Errorf("%w: %v", err, rerr)
					return false, err
				}
				return false, err
			}
		}

		if len(eventIdsWhereHost) > 0 {
			_, err = tx.Event.Update().
				Where(event.IDIn(eventIdsWhereHost...)).
				AddConfirmedCount(-1).
				AddConfirmedHosts(-1).
				Save(ctx)
			if err != nil {
				log.Printf("error while updating event: %s", err)
				if rerr := tx.Rollback(); rerr != nil {
					err = fmt.Errorf("%w: %v", err, rerr)
					return false, err
				}
				return false, err
			}
		}

		if len(eventIdsWhereCreator) > 0 {
			events, err := tx.Event.Query().
				Where(event.IDIn(eventIdsWhereCreator...)).
				All(ctx)
			if err != nil {
				log.Printf("error while getting events: %s", err)
				if rerr := tx.Rollback(); rerr != nil {
					err = fmt.Errorf("%w: %v", err, rerr)
					return false, err
				}
				return false, err
			}

			rand.Seed(time.Now().Unix())

			for _, event := range events {
				if event.ConfirmedHosts <= 0 {
					// delete event
					err = tx.Event.DeleteOne(event).Exec(ctx)
					if err != nil {
						if rerr := tx.Rollback(); rerr != nil {
							err = fmt.Errorf("%w: %v", err, rerr)
							return false, err
						}
						return false, err
					}

					allEventPics := append(event.LightEventPics, event.EventPics...)

					for _, pic := range allEventPics {
						objectToDeleteFullString := pic

						var cloudfrontDistribution string
						if config.C.AppEnv == "prod" {
							cloudfrontDistribution = "https://di7aab2ls1mmt.cloudfront.net/"
						} else if config.C.AppEnv == "dev" {
							cloudfrontDistribution = "https://d3pvchlba3rmqp.cloudfront.net/"
						}

						keysFromS3ToDelete = append(keysFromS3ToDelete, strings.ReplaceAll(objectToDeleteFullString, cloudfrontDistribution, ""))
					}

					// Send event cancel notifications
					eventsToCancel = append(eventsToCancel, EventToCancel{
						EventID:   event.ID,
						EventName: event.Name,
					})

				} else if event.ConfirmedHosts >= 1 {

					rows, allGuestsErr := tx.QueryContext(ctx, `
						SELECT d.token, eu.user_id FROM event_users eu
						LEFT JOIN devices d ON eu.user_id = d.user_id
						WHERE eu.event_id = ? AND eu.confirmed = true AND eu.admin = true AND NOT eu.user_id = ?;
					`, event.ID, *userId)
					if allGuestsErr != nil {
						if rerr := tx.Rollback(); rerr != nil {
							err = fmt.Errorf("%w: %v", err, rerr)
							return false, err
						}
						return false, err
					}

					affectedRows := 0
					var eventAdmins []int
					var eventAdminTokens []string
					for rows.Next() {
						var token *string
						var userID int
						if err := rows.Scan(&token, &userID); err != nil {
							log.Printf("Error scanning event_user row: %v", err)
							continue
						}

						eventAdmins = append(eventAdmins, userID)

						if token != nil {
							nonNilToken := *token
							eventAdminTokens = append(eventAdminTokens, nonNilToken)
						}

						affectedRows++
					}

					if affectedRows > 0 {
						eventAdmins = utils.RemoveIntDuplicates(eventAdmins)

						selectedAdmin := eventAdmins[rand.Intn(len(eventAdmins))]

						err = tx.EventUser.Update().
							Where(
								eventuser.And(
									eventuser.EventID(event.ID),
									eventuser.UserID(selectedAdmin),
								),
							).
							SetCreator(true).
							Exec(ctx)
						if err != nil {
							if rerr := tx.Rollback(); rerr != nil {
								err = fmt.Errorf("%w: %v", err, rerr)
								return false, err
							}
							return false, err
						}

						eventsToUpdate = append(eventsToUpdate, EventToUpdate{
							EventName:        event.Name,
							EventAdminTokens: eventAdminTokens,
						})
					}
				}
			}
		}
	}

	err = tx.EventUser.Update().
		Where(
			eventuser.InvitedBy(*userId),
		).
		SetInvitedBy(-1).
		Exec(ctx)
	if err != nil {
		if rerr := tx.Rollback(); rerr != nil {
			err = fmt.Errorf("%w: %v", err, rerr)
			return false, err
		}
		return false, err
	}

	_, err = tx.EventUser.Delete().
		Where(
			eventuser.UserID(*userId),
		).
		Exec(ctx)
	if err != nil {
		if rerr := tx.Rollback(); rerr != nil {
			err = fmt.Errorf("%w: %v", err, rerr)
			return false, err
		}
		return false, err
	}

	_, err = tx.Follow.Delete().
		Where(
			follow.Or(
				follow.FollowerID(*userId),
				follow.UserID(*userId),
			),
		).
		Exec(ctx)
	if err != nil {
		if rerr := tx.Rollback(); rerr != nil {
			err = fmt.Errorf("%w: %v", err, rerr)
			return false, err
		}
		return false, err
	}

	_, err = tx.Device.Delete().
		Where(
			device.UserID(*userId),
		).
		Exec(ctx)
	if err != nil {
		if rerr := tx.Rollback(); rerr != nil {
			err = fmt.Errorf("%w: %v", err, rerr)
			return false, err
		}
		return false, err
	}

	userToDelete, err := tx.User.Query().
		Where(
			user.ID(*userId),
		).
		Only(ctx)
	if err != nil {
		if rerr := tx.Rollback(); rerr != nil {
			err = fmt.Errorf("%w: %v", err, rerr)
			return false, err
		}
		return false, err
	}

	err = tx.User.
		DeleteOne(userToDelete).
		Exec(ctx)
	if err != nil {
		if rerr := tx.Rollback(); rerr != nil {
			err = fmt.Errorf("%w: %v", err, rerr)
			return false, err
		}
		return false, err
	}

	objectToDeleteFullString := userToDelete.ProfilePic

	if !strings.Contains(objectToDeleteFullString, "blueLobster") &&
		(strings.HasPrefix(objectToDeleteFullString, "https://di7aab2ls1mmt.cloudfront.net/") ||
			strings.HasPrefix(objectToDeleteFullString, "https://d3pvchlba3rmqp.cloudfront.net/")) {
		var cloudfrontDistribution string
		if config.C.AppEnv == "prod" {
			cloudfrontDistribution = "https://di7aab2ls1mmt.cloudfront.net/"
		} else if config.C.AppEnv == "dev" {
			cloudfrontDistribution = "https://d3pvchlba3rmqp.cloudfront.net/"
		}

		keysFromS3ToDelete = append(keysFromS3ToDelete, strings.ReplaceAll(objectToDeleteFullString, cloudfrontDistribution, ""))
	}

	ok := meilisearchUtils.RemoveUserFromMeili(*userId)
	if !ok {
		if rerr := tx.Rollback(); rerr != nil {
			err = fmt.Errorf("%w: %v", err, rerr)
			return false, err
		}
		return false, err
	}

	if err := tx.Commit(); err != nil {
		return false, err
	}

	err = firebaseUtils.AuthClient.DeleteUser(ctx, *firebaseUID)
	if err != nil {
		log.Printf("Error while deleting user from firebase: %s", err)
	}

	if len(keysFromS3ToDelete) > 0 {
		deleteEventPicsRes := awsS3.DeleteFromS3(keysFromS3ToDelete)
		if !deleteEventPicsRes {
			log.Printf("could not delete event pictures and profile pic from S3: %s", keysFromS3ToDelete)
		}
	}

	for _, eventData := range eventsToCancel {
		go func(eventID int, eventName string) {
			newctx, cancel := context.WithCancel(context.Background())
			defer cancel()

			rows, allGuestsErr := r.client.DB().QueryContext(newctx, `
				SELECT d.token FROM event_users eu
				JOIN devices d ON eu.user_id = d.user_id
				WHERE eu.event_id = ? AND eu.confirmed = true;
			`, eventID)
			if allGuestsErr != nil {
				return
			}

			var tokens []string
			affectedRows := 0

			for rows.Next() {
				var token string
				if err := rows.Scan(&token); err != nil {
					log.Printf("Error scanning event_user row: %v", err)
					continue
				}

				tokens = append(tokens, token)
				affectedRows++
			}

			if affectedRows > 0 {
				notifications.SendPushNotificationsWithDevices(newctx, tokens, "Happ", eventName+" has been canceled.")
			}

		}(eventData.EventID, eventData.EventName)
	}

	for _, eventData := range eventsToUpdate {
		go func(eventName string, eventAdminTokens []string) {
			newctx, cancel := context.WithCancel(context.Background())
			defer cancel()

			userName, err := r.client.User.Query().
				Where(
					user.ID(*userId),
				).
				Select(user.FieldName).
				String(newctx)
			if err != nil {
				return
			}

			notifications.SendPushNotificationsWithDevices(newctx, eventAdminTokens, "Happ", userName+" has leaved "+eventName)
		}(eventData.EventName, eventData.EventAdminTokens)
	}

	return true, nil
}

// AddOrRemoveUser is the resolver for the addOrRemoveUser field.
func (r *mutationResolver) AddOrRemoveUser(ctx context.Context, followUserID int, isFollow bool) (*model.AddResponse, error) {
	userId, authErr := utils.IsAuth(ctx)
	if authErr != nil {
		return nil, authErr
	}

	if isFollow {
		err := r.client.Follow.Create().
			SetFollowerID(*userId).
			SetUserID(followUserID).
			SetValid(true).
			OnConflict().
			SetValid(true).
			Exec(ctx)
		if err != nil {
			// if unchanged is true then ignore isFriend
			// if unchanged is true then make isFriend false
			// if unchaged is true value is 0
			return &model.AddResponse{
				Value:     0,
				Unchanged: true,
			}, nil
		}

		go func() {
			newctx, cancel := context.WithCancel(context.Background())
			defer cancel()

			userName, err := r.client.User.Query().
				Where(
					user.ID(*userId),
				).
				Select(user.FieldName).
				String(newctx)
			if err != nil {
				return
			}

			notifications.SendPushNotifications(r.client, newctx, followUserID, "Happ", userName+" has added you as a friend!")
		}()

		return &model.AddResponse{
			Value:     1,
			Unchanged: false,
		}, nil
	}

	// err := r.client.Follow.Create().
	// 	SetFollowerID(*userId).
	// 	SetUserID(followUserID).
	// 	SetValid(false).
	// 	OnConflict().
	// 	SetValid(false).
	// 	Exec(ctx)

	_, err := r.client.Follow.Delete().
		Where(
			follow.FollowerID(*userId),
			follow.UserID(followUserID),
		).
		Exec(ctx)
	if err != nil {
		return &model.AddResponse{
			Value:     0,
			Unchanged: true,
		}, nil
	}

	return &model.AddResponse{
		Value:     -1,
		Unchanged: false,
	}, nil
}

// NewEvent is the resolver for the newEvent field.
func (r *mutationResolver) NewEvent(ctx context.Context, input model.NewEventInput) (*model.CreateEventResponse, error) {
	userId, authErr := utils.IsAuth(ctx)
	if authErr != nil {
		return nil, authErr
	}

	var eventPics []string
	var lightEventPics []string

	// User creates Event
	// user gets

	// FOR GETTING BOTH NONCE AND KEY, DECODE AND THEN DECRYPT

	key, nonce, err := newEventUtils.CreateEventKeys()
	if err != nil {
		log.Printf("Error while creating keys: %s", err)
		// return error could not create event
		return nil, fmt.Errorf("could not create event, try again later")
	}

	for i := 0; i < len(input.EventPics); i++ { //i, picture := range input.EventPics {
		content, err := io.ReadAll(input.EventPics[i].File)
		if err != nil {
			// could not read file #i
			return nil, fmt.Errorf("could not read picture #%s", strconv.Itoa(i))
		}

		uuid := uuid.New()
		uuidString := uuid.String()
		key := "eventPictures/" + strconv.Itoa(i) + "-" + uuidString + ".jpg"

		var fullKey string
		if config.C.AppEnv == "prod" {
			fullKey = "https://di7aab2ls1mmt.cloudfront.net/" + key
		} else if config.C.AppEnv == "dev" {
			fullKey = "https://d3pvchlba3rmqp.cloudfront.net/" + key
		}

		eventPics = append(eventPics, fullKey)

		file := bytes.NewReader(content)
		uploadRes := awsS3.UploadToS3(key, file)
		if !uploadRes {
			// return error could not create event try again later
			return nil, fmt.Errorf("could not create event, try again later")
		}
	}

	for i := 0; i < len(input.EventPicsLight); i++ {
		content, err := io.ReadAll(input.EventPicsLight[i].File)
		if err != nil {
			// could not read file #i
			return nil, fmt.Errorf("could not read picture #%s", strconv.Itoa(i))
		}

		uuid := uuid.New()
		uuidString := uuid.String()
		key := "lightEventPictures/" + strconv.Itoa(i) + "-" + uuidString + ".jpg"

		var fullKey string
		if config.C.AppEnv == "prod" {
			fullKey = "https://di7aab2ls1mmt.cloudfront.net/" + key
		} else if config.C.AppEnv == "dev" {
			fullKey = "https://d3pvchlba3rmqp.cloudfront.net/" + key
		}

		lightEventPics = append(lightEventPics, fullKey)

		file := bytes.NewReader(content)
		uploadRes := awsS3.UploadToS3(key, file)
		if !uploadRes {
			// return error could not create event try again later
			return nil, fmt.Errorf("could not create event, try again later")
		}
	}

	msInt, _ := strconv.ParseInt(input.EventDate, 10, 64)
	eventDate := time.Unix(0, msInt*int64(time.Millisecond))

	coords := &schematype.Point{
		input.Latitude,
		input.Longitude,
	}

	event, err := r.client.Event.Create().
		SetName(input.Name).
		SetDescription(input.Description).
		SetEventPics(eventPics).
		SetEventDate(eventDate).
		SetLightEventPics(lightEventPics).
		SetEventPlace(input.EventPlace).
		SetCoords(coords).
		SetEventKey(*key).
		SetEventNonce(*nonce).
		Save(ctx)
	if err != nil {
		log.Println(err)
		// return error could not create event
		return nil, fmt.Errorf("could not create event, try again later")
	}

	_, eventUserErr := r.client.EventUser.Create().
		SetEventID(event.ID).
		SetUserID(*userId).
		SetAdmin(true).
		SetCreator(true).
		SetConfirmed(true).
		SetInvitedBy(*userId).
		Save(ctx)
	if eventUserErr != nil {
		_ = r.client.Event.DeleteOne(event).Exec(ctx)
		return nil, fmt.Errorf("could not create event, try again later")
	}

	return &model.CreateEventResponse{
		Event: event,
		// Errors: &model.ErrorResponse{}[]
	}, nil
}

// InviteGuestsAndOrganizers is the resolver for the inviteGuestsAndOrganizers field.
func (r *mutationResolver) InviteGuestsAndOrganizers(ctx context.Context, guests []int, organizers []int, eventID int) (bool, error) {
	currentUserID, authErr := utils.IsAuth(ctx)
	if authErr != nil {
		return false, authErr
	}

	// bulk := make([]*ent.EventUserCreate, len(guests)+len(organizers))
	guestsBulk := make([]*ent.EventUserCreate, len(guests))
	organizersBulk := make([]*ent.EventUserCreate, len(organizers))

	userIds := make([]int, len(guests)+len(organizers))

	// Copy elements from array1 and array2 into the joinedArray
	copy(userIds[:len(guests)], guests)
	copy(userIds[len(organizers):], organizers)

	for i, userId := range guests {
		guestsBulk[i] = r.client.EventUser.Create().
			SetEventID(eventID).
			SetUserID(userId).
			SetInvitedBy(*currentUserID).
			SetAdmin(false)
	}

	for i, userId := range organizers {
		organizersBulk[i] = r.client.EventUser.Create().
			SetEventID(eventID).
			SetUserID(userId).
			SetInvitedBy(*currentUserID).
			SetAdmin(true)
	}

	bulk := append(guestsBulk, organizersBulk...)

	_, err := r.client.EventUser.CreateBulk(bulk...).Save(ctx)
	if err != nil {
		return false, nil
	}

	go func() {

		newctx, cancel := context.WithCancel(context.Background())
		defer cancel()

		userName, err := r.client.User.Query().
			Where(
				user.ID(*currentUserID),
			).
			Select(user.FieldName).
			String(newctx)
		if err != nil {
			return
		}

		eventName, err := r.client.Event.Query().
			Where(
				event.ID(eventID),
			).
			Select(event.FieldName).
			String(newctx)
		if err != nil {
			return
		}

		notifications.SendManyPushNotifications(r.client, newctx, userIds, "Happ", userName+" has invited you to "+eventName)
	}()

	return true, nil
}

// AcceptInvitation is the resolver for the acceptInvitation field.
func (r *mutationResolver) AcceptInvitation(ctx context.Context, eventID int) (*model.AcceptInvitationResponse, error) {
	// WHEN USER CREATES EVENT (QR)
	// a key and nonce are generated, encrypted and saved in the database.

	// ACCEPT INVITATION FLOW (ONLINE METHOD)
	// User accepts invitation
	// `confirmed` row in event_users flips to true
	// server sends qr code to client (qr code has encrypted userID)
	// client saves it to local storage

	// (when read by organizer)
	// Organizer decode QR code and send encrypted string to server where it will be decrypted.
	// Server then sends response to organizer if user was accepted or not (do it in less than 1 second)

	userId, authErr := utils.IsAuth(ctx)
	if authErr != nil {
		return nil, authErr
	}

	eventUser, err := r.client.EventUser.Query().
		Where(
			eventuser.And(
				eventuser.EventID(eventID),
				eventuser.UserID(*userId),
			),
		).
		Only(ctx)
	if err != nil {
		log.Printf("error while getting event user: %s", err)
		return nil, err
	}

	if eventUser.Confirmed {
		return nil, fmt.Errorf("user has is confirmed")
	}

	thisEvent, err := r.client.Event.Query().
		Where(event.ID(eventID)).
		Only(ctx)
	if err != nil {
		return nil, err
	}

	tx, err := r.client.Tx(ctx)
	if err != nil {
		return nil, err
	}

	_, err = tx.EventUser.Update().
		Where(
			eventuser.And(
				eventuser.EventID(eventID),
				eventuser.UserID(*userId),
			),
		).
		SetConfirmed(true).
		Save(ctx)
	if err != nil {
		log.Printf("error while updating event user: %s", err)
		if rerr := tx.Rollback(); rerr != nil {
			err = fmt.Errorf("%w: %v", err, rerr)
			return nil, err
		}
		return nil, err
	}

	if eventUser.Admin {
		_, err = tx.Event.Update().
			Where(event.ID(eventID)).
			AddConfirmedCount(1).
			AddConfirmedHosts(1).
			Save(ctx)
		if err != nil {
			log.Printf("error while updating event: %s", err)
			if rerr := tx.Rollback(); rerr != nil {
				err = fmt.Errorf("%w: %v", err, rerr)
				return nil, err
			}
			return nil, err
		}
	} else {
		_, err = tx.Event.Update().
			Where(event.ID(eventID)).
			AddConfirmedCount(1).
			Save(ctx)
		if err != nil {
			log.Printf("error while updating event: %s", err)
			if rerr := tx.Rollback(); rerr != nil {
				err = fmt.Errorf("%w: %v", err, rerr)
				return nil, err
			}
			return nil, err
		}
	}

	if err := tx.Commit(); err != nil {
		return nil, err
	}

	go func() {
		newctx, cancel := context.WithCancel(context.Background())
		defer cancel()

		rows, err := r.client.DB().QueryContext(newctx, `
			SELECT d.token FROM event_users eu
			JOIN devices d ON eu.user_id = d.user_id
			WHERE eu.event_id = ? AND eu.admin = true AND eu.confirmed = true;
		`, eventID)
		if err != nil {
			return
		}

		var tokens []string
		affectedRows := 0

		for rows.Next() {
			var token string
			if err := rows.Scan(&token); err != nil {
				log.Printf("Error scanning event_user row: %v", err)
				return
			}

			tokens = append(tokens, token)
			affectedRows++
		}

		if affectedRows == 0 {
			return
		}

		userName, err := r.client.User.Query().
			Where(
				user.ID(*userId),
			).
			Select(user.FieldName).
			String(newctx)
		if err != nil {
			return
		}

		notifications.SendPushNotificationsWithDevices(newctx, tokens, "Happ", userName+" has accepted the invitation for "+thisEvent.Name)
	}()

	if eventUser.Admin {
		return &model.AcceptInvitationResponse{
			CypherText: nil,
			IsHost:     true,
		}, nil
	}

	keyChannel := make(chan awsParameterStore.KeysResGoroutine)
	nonceChannel := make(chan awsParameterStore.KeysResGoroutine)

	go awsParameterStore.GetEventKeyParameterGoroutine("Happ_events_e", keyChannel)
	go awsParameterStore.GetEventKeyParameterGoroutine("Happ_events_o", nonceChannel)

	keyRes, nonceRes := <-keyChannel, <-nonceChannel

	if keyRes.Error != nil {
		log.Printf("error while calling getEventKeyParameterGoroutine: %s", err)
		return nil, err
	}

	if nonceRes.Error != nil {
		log.Printf("error while calling getEventKeyParameterGoroutine: %s", err)
		return nil, err
	}

	keyBytes, nonceBytes := keyRes.Value, nonceRes.Value

	encryptedKey := thisEvent.EventKey
	encryptedNonce := thisEvent.EventNonce

	decodedEncryptedKey, err := base64.StdEncoding.DecodeString(encryptedKey)
	if err != nil {
		log.Printf("error while decoding encrypted key: %s", err)
		return nil, err
	}

	decodedEncryptedNonce, err := base64.StdEncoding.DecodeString(encryptedNonce)
	if err != nil {
		log.Printf("error while decoding encrypted nonce: %s", err)
		return nil, err
	}

	decryptedKey, err := AES_Encryption.Decrypt(decodedEncryptedKey, []byte(*keyBytes), []byte(*nonceBytes))
	if err != nil {
		log.Printf("error while decrypting key: %s", err)
		return nil, err
	}

	decryptedNonce, err := AES_Encryption.Decrypt(decodedEncryptedNonce, []byte(*keyBytes), []byte(*nonceBytes))
	if err != nil {
		log.Printf("error while decrypting nonce: %s", err)
		return nil, err
	}
	textToBeEncrypted := strconv.Itoa(*userId)

	cypherTextBytes, err := AES_Encryption.Encrypt([]byte(textToBeEncrypted), decryptedKey, decryptedNonce)
	if err != nil {
		log.Printf("error while creating cypher text nonce: %s", err)
		return nil, err
	}

	cypherText := base64.StdEncoding.EncodeToString(cypherTextBytes)

	return &model.AcceptInvitationResponse{
		CypherText: &cypherText,
		IsHost:     false,
	}, nil

	// GET FROM DB

	// panic(log.Errorf("not implemented"))
}

// UpdateEvent is the resolver for the updateEvent field.
func (r *mutationResolver) UpdateEvent(ctx context.Context, input model.UpdateEventInput, eventID int) (*model.CreateEventResponse, error) {
	userId, authErr := utils.IsAuth(ctx)
	if authErr != nil {
		return nil, authErr
	}

	var errors []*model.ErrorResponse

	eventUser, err := r.client.EventUser.Query().
		Where(
			eventuser.And(
				eventuser.EventID(eventID),
				eventuser.UserID(*userId),
			),
		).
		Only(ctx)
	if err != nil {
		log.Printf("error while getting event user: %s", err)
		return nil, err
	}

	if !eventUser.Admin {
		errorMessage := &model.ErrorResponse{
			Field:   "Global",
			Message: "Operation not allowed",
		}
		errors = append(errors, errorMessage)
		return &model.CreateEventResponse{
			Event:  nil,
			Errors: errors,
		}, nil
	}

	event, err := r.client.Event.Query().
		Where(event.ID(eventID)).
		Only(ctx)
	if err != nil {
		return nil, err
	}

	updateEvent := event.Update()

	if input.Name != nil {
		updateEvent = updateEvent.SetName(*input.Name)
	}

	if input.Description != nil {
		updateEvent = updateEvent.SetDescription(*input.Description)
	}

	var objectsToDelete []string

	var newObjectsToDeleteIfFailure []string

	rollback := false

	defer func() {
		if rollback && len(newObjectsToDeleteIfFailure) > 0 {
			deletePicsRes := awsS3.DeleteFromS3(newObjectsToDeleteIfFailure)
			if !deletePicsRes {
				log.Printf("could not delete uploaded pictures from S3 after defer: %s", newObjectsToDeleteIfFailure)
			}
		}
	}()

	if input.EventPics != nil {
		var eventPics []string
		var lightEventPics []string

		eventPics = event.EventPics
		lightEventPics = event.LightEventPics

		// var objectsToDelete []string

		for _, pic := range input.EventPics {
			index := pic.Index
			action := pic.Action

			if action == "REPLACE" {
				objectsToDelete = append(objectsToDelete, eventPics[index])
				content, err := io.ReadAll(pic.File.File)
				if err != nil {
					rollback = true
					return nil, fmt.Errorf("could not read picture #%s", strconv.Itoa(index))
				}

				uuid := uuid.New()
				uuidString := uuid.String()
				key := "eventPictures/" + strconv.Itoa(index) + "-" + uuidString + ".jpg"

				var fullKey string
				if config.C.AppEnv == "prod" {
					fullKey = "https://di7aab2ls1mmt.cloudfront.net/" + key
				} else if config.C.AppEnv == "dev" {
					fullKey = "https://d3pvchlba3rmqp.cloudfront.net/" + key
				}

				eventPics[index] = fullKey

				file := bytes.NewReader(content)
				uploadRes := awsS3.UploadToS3(key, file)
				if !uploadRes {
					rollback = true
					return nil, fmt.Errorf("could not create event, try again later")
				}

				newObjectsToDeleteIfFailure = append(newObjectsToDeleteIfFailure, key)
			}
		}

		for _, pic := range input.EventPics {
			index := pic.Index
			action := pic.Action

			if action == "DELETE" {
				objectsToDelete = append(objectsToDelete, eventPics[index])
				eventPics = append(eventPics[:index], eventPics[index+1:]...)
			}
		}

		for _, pic := range input.EventPics {
			action := pic.Action

			if action == "ADD" {
				content, err := io.ReadAll(pic.File.File)
				if err != nil {
					rollback = true
					return nil, fmt.Errorf("could not read picture #%s", strconv.Itoa(len(eventPics)))
				}

				uuid := uuid.New()
				uuidString := uuid.String()
				key := "eventPictures/" + strconv.Itoa(len(eventPics)) + "-" + uuidString + ".jpg"

				var fullKey string
				if config.C.AppEnv == "prod" {
					fullKey = "https://di7aab2ls1mmt.cloudfront.net/" + key
				} else if config.C.AppEnv == "dev" {
					fullKey = "https://d3pvchlba3rmqp.cloudfront.net/" + key
				}

				eventPics = append(eventPics, fullKey)

				file := bytes.NewReader(content)
				uploadRes := awsS3.UploadToS3(key, file)
				if !uploadRes {
					rollback = true
					return nil, fmt.Errorf("could not create event, try again later")
				}
				newObjectsToDeleteIfFailure = append(newObjectsToDeleteIfFailure, key)
			}
		}

		for _, pic := range input.EventPicsLight {
			index := pic.Index
			action := pic.Action

			if action == "REPLACE" {
				objectsToDelete = append(objectsToDelete, lightEventPics[index])

				content, err := io.ReadAll(pic.File.File)
				if err != nil {
					rollback = true
					return nil, fmt.Errorf("could not read picture #%s", strconv.Itoa(index))
				}

				uuid := uuid.New()
				uuidString := uuid.String()
				key := "lightEventPictures/" + strconv.Itoa(index) + "-" + uuidString + ".jpg"

				var fullKey string
				if config.C.AppEnv == "prod" {
					fullKey = "https://di7aab2ls1mmt.cloudfront.net/" + key
				} else if config.C.AppEnv == "dev" {
					fullKey = "https://d3pvchlba3rmqp.cloudfront.net/" + key
				}

				lightEventPics[index] = fullKey

				file := bytes.NewReader(content)
				uploadRes := awsS3.UploadToS3(key, file)
				if !uploadRes {
					rollback = true
					return nil, fmt.Errorf("could not create event, try again later")
				}
				newObjectsToDeleteIfFailure = append(newObjectsToDeleteIfFailure, key)
			}
		}

		for _, pic := range input.EventPicsLight {
			index := pic.Index
			action := pic.Action

			if action == "DELETE" {
				objectsToDelete = append(objectsToDelete, lightEventPics[index])
				lightEventPics = append(lightEventPics[:index], lightEventPics[index+1:]...)
			}
		}

		for _, pic := range input.EventPicsLight {
			action := pic.Action

			if action == "ADD" {
				content, err := io.ReadAll(pic.File.File)
				if err != nil {
					rollback = true
					return nil, fmt.Errorf("could not read picture #%s", strconv.Itoa(len(lightEventPics)))
				}

				uuid := uuid.New()
				uuidString := uuid.String()
				key := "lightEventPictures/" + strconv.Itoa(len(lightEventPics)) + "-" + uuidString + ".jpg"

				var fullKey string
				if config.C.AppEnv == "prod" {
					fullKey = "https://di7aab2ls1mmt.cloudfront.net/" + key
				} else if config.C.AppEnv == "dev" {
					fullKey = "https://d3pvchlba3rmqp.cloudfront.net/" + key
				}

				lightEventPics = append(lightEventPics, fullKey)

				file := bytes.NewReader(content)
				uploadRes := awsS3.UploadToS3(key, file)
				if !uploadRes {
					rollback = true
					return nil, fmt.Errorf("could not create event, try again later")
				}
				newObjectsToDeleteIfFailure = append(newObjectsToDeleteIfFailure, key)
			}
		}

		updateEvent = updateEvent.SetEventPics(eventPics).SetLightEventPics(lightEventPics)
	}

	if input.Latitude != nil && input.Longitude != nil {
		coords := &schematype.Point{
			*input.Latitude,
			*input.Longitude,
		}

		updateEvent = updateEvent.SetCoords(coords)
	}

	if input.EventPlace != nil {
		updateEvent = updateEvent.SetEventPlace(*input.EventPlace)
	}

	if input.EventDate != nil {
		msInt, _ := strconv.ParseInt(*input.EventDate, 10, 64)
		eventDateTime := time.Unix(0, msInt*int64(time.Millisecond))

		updateEvent = updateEvent.SetEventDate(eventDateTime)
	}

	updatedEvent, err := updateEvent.Save(ctx)
	if err != nil {
		rollback = true
		log.Println(err)
		// return error could not create event
		return nil, fmt.Errorf("could not create event, try again later")
	}

	if len(objectsToDelete) > 0 {
		newObjectKeys := make([]string, len(objectsToDelete))
		for i, objectToDelete := range objectsToDelete {
			objectToDeleteFullString := objectToDelete

			var cloudfrontDistribution string
			if config.C.AppEnv == "prod" {
				cloudfrontDistribution = "https://di7aab2ls1mmt.cloudfront.net/"
			} else if config.C.AppEnv == "dev" {
				cloudfrontDistribution = "https://d3pvchlba3rmqp.cloudfront.net/"
			}

			newObjectKeys[i] = strings.ReplaceAll(objectToDeleteFullString, cloudfrontDistribution, "")
		}

		deleteEventPicsRes := awsS3.DeleteFromS3(newObjectKeys)
		if !deleteEventPicsRes {
			log.Printf("could not delete event pictures from S3: %s", newObjectKeys)
			// return nil, fmt.Errorf("could not delete previous image from aws s3")
		}
	}

	if input.EventDate != nil || input.EventPlace != nil || (input.Latitude != nil && input.Longitude != nil) {
		go func() {
			newctx, cancel := context.WithCancel(context.Background())
			defer cancel()

			rows, err := r.client.DB().QueryContext(newctx, `
				SELECT d.token FROM event_users eu
				JOIN devices d ON eu.user_id = d.user_id
				WHERE eu.event_id = ? AND eu.confirmed = true;
			`, eventID)
			if err != nil {
				log.Printf("Error fetching event_users for notifications: %v", err)
				return
			}

			var tokens []string
			affectedRows := 0

			for rows.Next() {
				var token string
				if err := rows.Scan(&token); err != nil {
					log.Printf("Error scanning event_user row: %v", err)
					return
				}

				tokens = append(tokens, token)
				affectedRows++
			}

			if affectedRows == 0 {
				return
			}

			if input.EventDate != nil {
				notifications.SendPushNotificationsWithDevices(newctx, tokens, "Happ", "The date for "+event.Name+" has been changed.")
			}

			if input.EventPlace != nil && (input.Latitude != nil && input.Longitude != nil) {
				notifications.SendPushNotificationsWithDevices(newctx, tokens, "Happ", "The location for "+event.Name+". Check it out!")
			} else {
				if input.EventPlace != nil {
					notifications.SendPushNotificationsWithDevices(newctx, tokens, "Happ", "The location for "+event.Name+". Check it out!")
				}

				if input.Latitude != nil && input.Longitude != nil {
					notifications.SendPushNotificationsWithDevices(newctx, tokens, "Happ", "The location for "+event.Name+". Check it out!")
				}
			}

		}()
	}

	return &model.CreateEventResponse{
		Event: updatedEvent,
		// Errors: &model.ErrorResponse{}[]
	}, nil
}

// DeleteEvent is the resolver for the deleteEvent field.
func (r *mutationResolver) DeleteEvent(ctx context.Context, eventID int) (*bool, error) {
	userId, authErr := utils.IsAuth(ctx)
	if authErr != nil {
		return nil, authErr
	}

	eventData, err := r.client.Event.Query().
		Where(
			event.ID(eventID),
		).
		Only(ctx)
	if err != nil {
		log.Printf("error while getting event on DeleteEvent(): %s", err)
		return nil, err
	}

	eventUser, err := r.client.EventUser.Query().
		Where(
			eventuser.And(
				eventuser.EventID(eventID),
				eventuser.UserID(*userId),
			),
		).
		Only(ctx)
	if err != nil {
		log.Printf("error while getting event user: %s", err)
		return nil, err
	}

	if !eventUser.Creator {
		errorNotAllowed := fmt.Errorf("operation not allowed")
		return nil, errorNotAllowed
	}

	// allGuests, allGuestsErr := r.client.EventUser.Query().
	// 	Where(
	// 		eventuser.EventID(eventID),
	// 	).
	// 	Select(eventuser.FieldUserID).
	// 	Ints(ctx)
	rows, allGuestsErr := r.client.DB().QueryContext(ctx, `
		SELECT d.token FROM event_users eu
		JOIN devices d ON eu.user_id = d.user_id
		WHERE eu.event_id = ? AND eu.confirmed = true;
	`, eventID)

	var tokens []string
	affectedRows := 0
	var eventName string
	var eventErr error

	if allGuestsErr == nil {
		for rows.Next() {
			var token string
			if err := rows.Scan(&token); err != nil {
				log.Printf("Error scanning event_user row: %v", err)
				continue
			}

			tokens = append(tokens, token)
			affectedRows++
		}

		if affectedRows > 0 {
			eventName, eventErr = r.client.Event.Query().
				Where(
					event.ID(eventID),
				).
				Select(event.FieldName).
				String(ctx)
		}
	}

	err = r.client.Event.
		DeleteOne(eventData).
		Exec(ctx)
	if err != nil {
		log.Printf("error while deleting event")
		return nil, err
	}

	var keysFromS3ToDelete []string

	allEventPics := append(eventData.LightEventPics, eventData.EventPics...)

	for _, pic := range allEventPics {
		objectToDeleteFullString := pic

		var cloudfrontDistribution string
		if config.C.AppEnv == "prod" {
			cloudfrontDistribution = "https://di7aab2ls1mmt.cloudfront.net/"
		} else if config.C.AppEnv == "dev" {
			cloudfrontDistribution = "https://d3pvchlba3rmqp.cloudfront.net/"
		}

		keysFromS3ToDelete = append(keysFromS3ToDelete, strings.ReplaceAll(objectToDeleteFullString, cloudfrontDistribution, ""))
	}

	deleteEventPicsRes := awsS3.DeleteFromS3(keysFromS3ToDelete)
	if !deleteEventPicsRes {
		log.Printf("could not delete profile picture from S3: %s", keysFromS3ToDelete)
	}

	if allGuestsErr == nil && eventErr == nil && affectedRows > 0 {
		go func() {
			newctx, cancel := context.WithCancel(context.Background())
			defer cancel()

			notifications.SendPushNotificationsWithDevices(newctx, tokens, "Happ", eventName+" has been canceled.")
		}()
	}

	value := true
	return &value, nil
}

// AddGuests is the resolver for the addGuests field.
func (r *mutationResolver) AddGuests(ctx context.Context, eventID int, userIds []int) (*bool, error) {
	userId, authErr := utils.IsAuth(ctx)
	if authErr != nil {
		return nil, authErr
	}

	var value bool

	eventUser, err := r.client.EventUser.Query().
		Where(
			eventuser.And(
				eventuser.EventID(eventID),
				eventuser.UserID(*userId),
			),
		).
		Only(ctx)
	if err != nil {
		value = false
		return &value, nil
	}

	if !eventUser.Admin {
		return nil, fmt.Errorf("operation not allowed")
	}

	// Add the guests to the event
	bulk := make([]*ent.EventUserCreate, len(userIds))
	for i, userID := range userIds {
		bulk[i] = r.client.EventUser.
			Create().
			SetEventID(eventID).
			SetUserID(userID).
			SetInvitedBy(*userId)
	}

	_, err = r.client.EventUser.CreateBulk(bulk...).Save(ctx)
	if err != nil {
		value = false
		return &value, err
	}

	value = true
	return &value, nil
}

// RemoveGuests is the resolver for the removeGuests field.
func (r *mutationResolver) RemoveGuests(ctx context.Context, eventID int, userIds []int) (*bool, error) {
	userId, authErr := utils.IsAuth(ctx)
	if authErr != nil {
		return nil, authErr
	}

	var value bool

	eventUser, err := r.client.EventUser.Query().
		Where(
			eventuser.And(
				eventuser.EventID(eventID),
				eventuser.UserID(*userId),
			),
		).
		Only(ctx)
	if err != nil {
		value = false
		return &value, err
	}

	if !eventUser.Admin {
		return nil, fmt.Errorf("operation not allowed")
	}

	tx, err := r.client.Tx(ctx)
	if err != nil {
		value = false
		return &value, err
	}

	// Add the guests to the event
	for _, userID := range userIds {
		_, err := tx.EventUser.
			Delete().
			Where(
				eventuser.And(
					eventuser.EventID(eventID),
					eventuser.UserID(userID),
				),
			).
			Exec(ctx)
		if err != nil {
			// tx.Rollback()
			value = false
			if rerr := tx.Rollback(); rerr != nil {
				err = fmt.Errorf("%w: %v", err, rerr)
				return &value, err
			}
			return &value, err
		}
	}

	_, err = tx.Event.Update().
		AddConfirmedCount(-len(userIds)).
		Where(event.ID(eventID)).
		// AddConfirmedHosts(1).
		Save(ctx)
	if err != nil {
		// tx.Rollback()
		log.Printf("error while updating event: %s", err)
		value = false
		if rerr := tx.Rollback(); rerr != nil {
			err = fmt.Errorf("%w: %v", err, rerr)
			return &value, err
		}
		return &value, err
	}

	if err := tx.Commit(); err != nil {
		value = false
		return &value, err
	}

	value = true
	return &value, nil
}

// ScanPass is the resolver for the scanPass field.
func (r *mutationResolver) ScanPass(ctx context.Context, eventID int, cypherText string) (*bool, error) {
	var value bool

	event, err := r.client.Event.Query().
		Where(event.ID(eventID)).
		Only(ctx)
	if err != nil {
		return nil, err
	}

	keyChannel := make(chan awsParameterStore.KeysResGoroutine)
	nonceChannel := make(chan awsParameterStore.KeysResGoroutine)

	go awsParameterStore.GetEventKeyParameterGoroutine("Happ_events_e", keyChannel)
	go awsParameterStore.GetEventKeyParameterGoroutine("Happ_events_o", nonceChannel)

	keyRes, nonceRes := <-keyChannel, <-nonceChannel

	if keyRes.Error != nil {
		log.Printf("error while calling getEventKeyParameterGoroutine: %s", err)
		return nil, err
	}

	if nonceRes.Error != nil {
		log.Printf("error while calling getEventKeyParameterGoroutine: %s", err)
		return nil, err
	}

	keyBytes, nonceBytes := keyRes.Value, nonceRes.Value

	encryptedKey := event.EventKey
	encryptedNonce := event.EventNonce

	decodedEncryptedKey, err := base64.StdEncoding.DecodeString(encryptedKey)
	if err != nil {
		log.Printf("error while decoding encrypted key: %s", err)
		return nil, err
	}

	decodedEncryptedNonce, err := base64.StdEncoding.DecodeString(encryptedNonce)
	if err != nil {
		log.Printf("error while decoding encrypted nonce: %s", err)
		return nil, err
	}

	decryptedKey, err := AES_Encryption.Decrypt(decodedEncryptedKey, []byte(*keyBytes), []byte(*nonceBytes))
	if err != nil {
		log.Printf("error while decrypting key: %s", err)
		value = false
		return &value, err
	}

	decryptedNonce, err := AES_Encryption.Decrypt(decodedEncryptedNonce, []byte(*keyBytes), []byte(*nonceBytes))
	if err != nil {
		log.Printf("error while decrypting nonce: %s", err)
		value = false
		return &value, err
	}

	decodedCypherText, err := base64.StdEncoding.DecodeString(cypherText)
	if err != nil {
		log.Printf("error while decoding cypher: %s", err)
		return nil, err
	}

	decryptedCypher, err := AES_Encryption.Decrypt(decodedCypherText, decryptedKey, decryptedNonce)
	if err != nil {
		log.Printf("error while decrypting cypher: %s", err)
		value = false
		return &value, err
	}

	userIdString := string(decryptedCypher)

	passUserId, _ := strconv.Atoi(userIdString)

	_, err = r.client.EventUser.Query().
		Where(
			eventuser.And(
				eventuser.EventID(eventID),
				eventuser.UserID(passUserId),
			),
		).
		Only(ctx)
	if err != nil {
		if ent.IsNotFound(err) {
			log.Printf("not on guets list: %s", err)
			value = false
			return &value, nil
		}
		return nil, err
	}

	value = true
	return &value, nil
}

// LeaveEvent is the resolver for the leaveEvent field.
func (r *mutationResolver) LeaveEvent(ctx context.Context, eventID int) (*bool, error) {
	userId, err := utils.IsAuth(ctx)
	if err != nil {
		return nil, err
	}

	var value bool

	eventUser, err := r.client.EventUser.Query().
		Where(
			eventuser.And(
				eventuser.EventID(eventID),
				eventuser.UserID(*userId),
			),
		).
		Only(ctx)
	if err != nil {
		log.Printf("error while getting event user: %s", err)
		return nil, err
	}

	tx, err := r.client.Tx(ctx)
	if err != nil {
		value = false
		return &value, err
	}

	_, err = tx.EventUser.
		Delete().
		Where(
			eventuser.And(
				eventuser.EventID(eventID),
				eventuser.UserID(*userId),
			),
		).
		Exec(ctx)
	if err != nil {
		log.Printf("error while deleting event user")
		if rerr := tx.Rollback(); rerr != nil {
			err = fmt.Errorf("%w: %v", err, rerr)
			return &value, err
		}
		return nil, err
	}

	if eventUser.Admin && eventUser.Confirmed {
		_, err = tx.Event.Update().
			AddConfirmedCount(-1).
			AddConfirmedHosts(-1).
			Where(event.ID(eventID)).
			Save(ctx)
		if err != nil {
			if rerr := tx.Rollback(); rerr != nil {
				err = fmt.Errorf("%w: %v", err, rerr)
				return &value, err
			}
			log.Printf("error while updating event: %s", err)
			value = false
			return &value, err
		}
	} else if !eventUser.Admin && eventUser.Confirmed {
		_, err = tx.Event.Update().
			AddConfirmedCount(-1).
			Where(event.ID(eventID)).
			Save(ctx)
		if err != nil {
			if rerr := tx.Rollback(); rerr != nil {
				err = fmt.Errorf("%w: %v", err, rerr)
				return &value, err
			}
			log.Printf("error while updating event: %s", err)
			value = false
			return &value, err
		}
	}

	if err := tx.Commit(); err != nil {
		value = false
		return &value, err
	}

	if eventUser.Confirmed {
		go func() {
			newctx, cancel := context.WithCancel(context.Background())
			defer cancel()

			rows, err := r.client.DB().QueryContext(newctx, `
				SELECT d.token FROM event_users eu
				JOIN devices d ON eu.user_id = d.user_id
				WHERE eu.event_id = ? AND eu.admin = true AND eu.confirmed = true;
			`, eventID)
			if err != nil {
				log.Printf("Error fetching event_users for notifications: %v", err)
				return
			}

			var tokens []string
			affectedRows := 0

			for rows.Next() {
				var token string
				if err := rows.Scan(&token); err != nil {
					log.Printf("Error scanning event_user row: %v", err)
					return
				}

				tokens = append(tokens, token)
				affectedRows++
			}

			if affectedRows == 0 {
				return
			}

			userName, err := r.client.User.Query().
				Where(user.ID(*userId)).
				Select(user.FieldName).
				String(newctx)
			if err != nil {
				log.Printf("Error getting user name: %v", err)
				return
			}

			eventName, err := r.client.Event.Query().
				Where(event.ID(eventID)).
				Select(event.FieldName).
				String(newctx)
			if err != nil {
				log.Printf("Error getting event name: %v", err)
				return
			}

			notifications.SendPushNotificationsWithDevices(newctx, tokens, "Happ", userName+" has leaved "+eventName)
		}()
	}

	value = true

	return &value, nil
}

// SaveDevice is the resolver for the saveDevice field.
func (r *mutationResolver) SaveDevice(ctx context.Context, token string) (*bool, error) {
	userId, err := utils.IsAuth(ctx)
	if err != nil {
		return nil, err
	}

	err = r.client.Device.Create().
		SetUserID(*userId).
		SetToken(token).
		OnConflict().
		SetUserID(*userId).
		Exec(ctx)
	if err != nil {
		return nil, fmt.Errorf("error creating device record")
	}

	value := true
	return &value, nil
}

// UpdateUser is the resolver for the updateUser field.
func (r *mutationResolver) UpdateUser(ctx context.Context, input model.UpdateUserInput) (*model.UpdateUserResponse, error) {
	userIdAndFUID, authErr := utils.IsAuthWithFUID(ctx)
	if authErr != nil {
		return nil, authErr
	}

	userId := userIdAndFUID.UserId
	firebaseUID := userIdAndFUID.FirebaseUID

	var errors []*model.ErrorResponse

	currentUser, err := r.client.User.Query().
		Where(
			user.ID(*userId),
		).
		Only(ctx)
	if err != nil {
		log.Println("could not get current user from DB on UpdateUser()")
		return nil, err
	}

	// claims := map[string]interface{}{
	// 	"id":                     newUser.ID,
	// 	"picture":                picture,
	// 	"username":               username,
	// 	"name":                   name,
	// 	"appleAuthorizationCode": authCode,
	// }
	// err = firebaseUtils.AuthClient.SetCustomUserClaims(ctx, *firebaseUID, claims)
	// if err != nil {
	// 	rollbackMeilisearchUserToo = true
	// 	rollback = true
	// 	return nil, fmt.Errorf("error setting custom claims: %v", err)
	// }

	firebaseUser, err := firebaseUtils.AuthClient.GetUser(context.Background(), *firebaseUID)
	if err != nil {
		log.Printf("error getting firebase user on UpdateUser(): %v\n", err)
		return nil, err
	}

	oldClaims := firebaseUser.CustomClaims

	updateUser := currentUser.Update()

	var newProfilePicKey *string

	if input.Name != nil {

		if len(*input.Name) == 0 {
			errors = append(errors, &model.ErrorResponse{
				Field:   "name",
				Message: "Name cannot be empty.",
			})
		}

		if len(*input.Name) > 30 {
			errors = append(errors, &model.ErrorResponse{
				Field:   "name",
				Message: "Name can't have more than 30 characters",
			})
		}

		oldClaims["name"] = *input.Name

		updateUser = updateUser.SetName(*input.Name)
	}

	if input.Username != nil {

		if len(*input.Username) == 0 {
			errors = append(errors, &model.ErrorResponse{
				Field:   "username",
				Message: "Username cannot be empty.",
			})
		}

		if len(*input.Username) > 30 {
			errors = append(errors, &model.ErrorResponse{
				Field:   "username",
				Message: "Username can't have more than 30 characters",
			})
		} else {

			valid := inputHandlers.IsValidUsername(*input.Username)

			if !valid {

				log.Println("username is not valid")
				errors = append(errors, &model.ErrorResponse{
					Field:   "username",
					Message: `Username can only contain lowercase letters, numbers, periods ".", and underscores "_". No Spaces.`,
				})

			} else {

				_, err := r.client.User.Query().
					Where(
						user.Username(*input.Username),
					).
					Select(user.FieldID).
					Int(ctx)

				if err == nil || (err != nil && !ent.IsNotFound(err)) {
					if err == nil {
						errors = append(errors, &model.ErrorResponse{
							Field:   "username",
							Message: "Username is taken.",
						})
					} else {
						log.Println("Error updating user: error searching for user with input.Username")

						return nil, err
					}

				} else {
					oldClaims["username"] = *input.Username
					updateUser = updateUser.SetUsername(*input.Username)
				}
			}
		}
	}

	if len(errors) > 0 {
		return &model.UpdateUserResponse{
			User:   nil,
			Errors: errors,
		}, nil
	}

	if input.ProfilePic != nil {
		content, err := io.ReadAll(input.ProfilePic.File)
		if err != nil {
			log.Println("could not read profile picture to update")

			return nil, fmt.Errorf("could not read profile picture to update")
		}

		uuid := uuid.New()
		uuidString := uuid.String()
		key := "userProfilePics/" + strconv.Itoa(*userId) + "_" + uuidString + ".jpg"
		// fileVersion := "?v=" + uuidString

		var preNewProfilePicKey string
		if config.C.AppEnv == "prod" {
			preNewProfilePicKey = "https://di7aab2ls1mmt.cloudfront.net/" + key // + fileVersion
			newProfilePicKey = &preNewProfilePicKey
		} else if config.C.AppEnv == "dev" {
			preNewProfilePicKey = "https://d3pvchlba3rmqp.cloudfront.net/" + key // + fileVersion
			newProfilePicKey = &preNewProfilePicKey
		}

		file := bytes.NewReader(content)
		uploadRes := awsS3.UploadToS3(key, file)
		if !uploadRes {
			log.Println("could not update user, try again later")

			return nil, fmt.Errorf("could not update user, try again later")
		}

		oldClaims["picture"] = *newProfilePicKey

		updateUser = updateUser.SetProfilePic(*newProfilePicKey)
	}

	if input.ProfilePic != nil || input.Name != nil || input.Username != nil {
		err = firebaseUtils.AuthClient.SetCustomUserClaims(context.Background(), *firebaseUID, oldClaims)
		if err != nil {
			log.Printf("error setting custom user claims on UpdateUser(): %v\n", err)

			if input.ProfilePic != nil {

				var keyFromS3ToDelete []string

				objectToDeleteFullString := *newProfilePicKey

				var cloudfrontDistribution string
				if config.C.AppEnv == "prod" {
					cloudfrontDistribution = "https://di7aab2ls1mmt.cloudfront.net/"
				} else if config.C.AppEnv == "dev" {
					cloudfrontDistribution = "https://d3pvchlba3rmqp.cloudfront.net/"
				}

				keyFromS3ToDelete = append(keyFromS3ToDelete, strings.ReplaceAll(objectToDeleteFullString, cloudfrontDistribution, ""))

				deleteEventPicsRes := awsS3.DeleteFromS3(keyFromS3ToDelete)
				if !deleteEventPicsRes {
					log.Printf("could not delete profile picture from S3: %s", keyFromS3ToDelete)
				}
			}

			return nil, err
		}

		res := meilisearchUtils.UpdateMeiliUser(
			*userId, input.Username, input.Name, newProfilePicKey,
		)

		if !res {
			log.Println("Error updating user: meilisearch user update failed")

			if input.ProfilePic != nil {

				var keyFromS3ToDelete []string

				objectToDeleteFullString := *newProfilePicKey

				var cloudfrontDistribution string
				if config.C.AppEnv == "prod" {
					cloudfrontDistribution = "https://di7aab2ls1mmt.cloudfront.net/"
				} else if config.C.AppEnv == "dev" {
					cloudfrontDistribution = "https://d3pvchlba3rmqp.cloudfront.net/"
				}

				keyFromS3ToDelete = append(keyFromS3ToDelete, strings.ReplaceAll(objectToDeleteFullString, cloudfrontDistribution, ""))

				deleteEventPicsRes := awsS3.DeleteFromS3(keyFromS3ToDelete)
				if !deleteEventPicsRes {
					log.Printf("could not delete profile picture from S3: %s", keyFromS3ToDelete)
				}
			}

			return nil, err
		}
	}

	updatedUser, err := updateUser.Save(ctx)
	if err != nil {
		log.Printf("Error updating user .Save(): %s", err)

		if input.ProfilePic != nil {
			// keyFromS3ToDelete := []string{*newProfilePicKey}

			var keyFromS3ToDelete []string

			objectToDeleteFullString := *newProfilePicKey

			var cloudfrontDistribution string
			if config.C.AppEnv == "prod" {
				cloudfrontDistribution = "https://di7aab2ls1mmt.cloudfront.net/"
			} else if config.C.AppEnv == "dev" {
				cloudfrontDistribution = "https://d3pvchlba3rmqp.cloudfront.net/"
			}

			keyFromS3ToDelete = append(keyFromS3ToDelete, strings.ReplaceAll(objectToDeleteFullString, cloudfrontDistribution, ""))

			deleteEventPicsRes := awsS3.DeleteFromS3(keyFromS3ToDelete)
			if !deleteEventPicsRes {
				log.Printf("could not delete profile picture from S3: %s", keyFromS3ToDelete)
			}
		}

		var meiliOldUsername *string
		var meiliOldName *string
		var meiliOldPicture *string

		if input.Username != nil {
			meiliOldUsername = &currentUser.Username
		}
		if input.Name != nil {
			meiliOldName = &currentUser.Name
		}
		if input.ProfilePic != nil {
			meiliOldPicture = &currentUser.ProfilePic
		}

		res := meilisearchUtils.UpdateMeiliUser(
			*userId, meiliOldUsername, meiliOldName, meiliOldPicture,
		)

		if !res {
			log.Printf("Error maintaing consistent state while updating user. .Save() failed, meilisearch rollback failed for user: %s", strconv.Itoa(*userId))
		}

		return nil, fmt.Errorf("error while updating user")
	}

	if input.ProfilePic != nil {

		objectToDeleteFullString := currentUser.ProfilePic

		if !strings.Contains(objectToDeleteFullString, "blueLobster") &&
			(strings.HasPrefix(objectToDeleteFullString, "https://di7aab2ls1mmt.cloudfront.net/") ||
				strings.HasPrefix(objectToDeleteFullString, "https://d3pvchlba3rmqp.cloudfront.net/")) {

			var keyFromS3ToDelete []string

			var cloudfrontDistribution string
			if config.C.AppEnv == "prod" {
				cloudfrontDistribution = "https://di7aab2ls1mmt.cloudfront.net/"
			} else if config.C.AppEnv == "dev" {
				cloudfrontDistribution = "https://d3pvchlba3rmqp.cloudfront.net/"
			}

			keyFromS3ToDelete = append(keyFromS3ToDelete, strings.ReplaceAll(objectToDeleteFullString, cloudfrontDistribution, ""))

			deleteEventPicsRes := awsS3.DeleteFromS3(keyFromS3ToDelete)
			if !deleteEventPicsRes {
				log.Printf("could not delete profile picture from S3: %s", keyFromS3ToDelete)
			}
		}

	}

	return &model.UpdateUserResponse{
		User:   updatedUser,
		Errors: nil,
	}, nil
}

// User is the resolver for the user field.
func (r *queryResolver) User(ctx context.Context, username string) (*ent.User, error) {
	return r.client.User.Query().Where(user.Username(username)).Only(ctx)
}

// UserFromID is the resolver for the userFromId field.
func (r *queryResolver) UserFromID(ctx context.Context, id int) (*ent.User, error) {
	return r.client.User.Query().Where(user.ID(id)).Only(ctx)
}

// SearchUsers is the resolver for the searchUsers field.
func (r *queryResolver) SearchUsers(ctx context.Context, search string, userSearching int) ([]*ent.User, error) {
	_, err := utils.SaveUserIdInHeader(ctx, userSearching)
	if err != nil {
		return nil, err
	}

	trimmedSearch := strings.TrimSpace(search)

	var users []*ent.User
	res, err := meilisearchUtils.GetUsersFromMeili(trimmedSearch, []int{})
	if err != nil {
		// log.Println(res)
		// return nil, err

		// or show empty array of users
		return users, nil
	}

	if len(res) == 0 {
		return users, nil
	}

	for _, user := range res {
		users = append(
			users,
			&ent.User{
				ID:         int(user.(map[string]interface{})["id"].(float64)),
				Username:   user.(map[string]interface{})["username"].(string),
				Name:       user.(map[string]interface{})["name"].(string),
				ProfilePic: user.(map[string]interface{})["profilePic"].(string),
			},
		)
	}

	return users, nil
	// panic(log.Errorf("not implemented"))
}

// GetUserEvents is the resolver for the getUserEvents field.
func (r *queryResolver) GetUserEvents(ctx context.Context, limit int, idsList []int) (*model.PaginatedEventResults, error) {
	userId, authErr := utils.IsAuth(ctx)
	if authErr != nil {
		return nil, authErr
	}

	var realLimit int

	// if len(idsList) == 0 {
	// 	realLimit = 10
	// } else {
	// 	realLimit = 25
	// }

	realLimit = 10

	realLimitPlusOne := realLimit + 1

	// var events []*ent.Event
	var eventInvitesRes []*model.EventInviteRes

	var stringIdsList []string

	for _, id := range idsList {
		stringIdsList = append(stringIdsList, strconv.Itoa(id))
	}

	var args []interface{}
	args = append(args, *userId) // add userId to args

	var params []string
	for _, id := range stringIdsList {
		// convert id to int and append to args
		intId, err := strconv.Atoi(id)
		if err != nil {
			return nil, err // handle error
		}
		args = append(args, intId)
		params = append(params, "?")
	}

	// join params with commas
	placeholders := strings.Join(params, ",")

	args = append(args, realLimitPlusOne)

	query := `
		select e.*, eu.invited_by, eu.admin, eu.creator from events e
		inner join event_users eu
			on (e.id = eu.event_id)
			and (eu.user_id = ?)
			and (eu.confirmed = true)
	`

	if len(placeholders) > 0 {
		query += fmt.Sprintf("where e.id not in (%s) ", placeholders)
	}

	query += `
		order by e.event_date ASC
		limit ?
	`

	res, err := r.client.QueryContext(ctx, query, args...)
	if err != nil {
		log.Println(err)
		return nil, err
	}

	for res.Next() {
		var id int
		var name string
		var description string
		var confirmed_count int
		var event_pics string
		var light_event_pics string
		var event_date time.Time
		var created_at time.Time
		var updated_at time.Time
		var coords schematype.Point
		var invited_by int
		var event_key string
		var event_nonce string
		var confirmed_hosts int
		var admin bool
		var creator bool
		var event_place string

		if err := res.Scan(
			&id,
			&name,
			&description,
			&confirmed_count,
			&event_pics,
			&event_date,
			&coords,
			&created_at,
			&updated_at,
			&light_event_pics,
			&event_key,
			&event_nonce,
			&confirmed_hosts,
			&event_place,
			&invited_by,
			&admin,
			&creator,
		); err != nil {
			// Check for a scan error.
			// Query rows will be closed with defer.
			log.Println(err)
			return nil, err
		}

		var eventPics []string
		json.Unmarshal([]byte(event_pics), &eventPics)

		var lightEventPics []string
		json.Unmarshal([]byte(light_event_pics), &lightEventPics)

		event := ent.Event{
			ID:             id,
			Name:           name,
			Description:    description,
			ConfirmedCount: confirmed_count,
			ConfirmedHosts: confirmed_hosts,
			EventPics:      eventPics,
			LightEventPics: lightEventPics,
			EventDate:      event_date,
			EventPlace:     event_place,
			Coords:         &coords,
			CreatedAt:      created_at,
			UpdatedAt:      updated_at,
		}

		invitedUserInfo := model.InvitedUserInfo{
			IsConfirmed: true,
			IsHost:      admin,
			IsCreator:   creator,
		}

		eventInviteRes := model.EventInviteRes{
			Event:           &event,
			InvitedByUserID: invited_by,
			InvitedUserInfo: &invitedUserInfo,
		}

		// events = append(events, &event)
		eventInvitesRes = append(eventInvitesRes, &eventInviteRes)
	}

	res.Close()

	if len(eventInvitesRes) < realLimit {
		realLimit = len(eventInvitesRes)
	}

	return &model.PaginatedEventResults{
		Events:  eventInvitesRes[0:realLimit],
		HasMore: len(eventInvitesRes) == realLimitPlusOne,
	}, nil

	// return eventInvitesRes, nil
	// select * from events
	// left join
}

// GetUserEventsFromFriends is the resolver for the getUserEventsFromFriends field.
func (r *queryResolver) GetUserEventsFromFriends(ctx context.Context, limit int, idsList []int) (*model.PaginatedEventResults, error) {
	userId, authErr := utils.IsAuth(ctx)
	if authErr != nil {
		return nil, authErr
	}

	realLimit := 8

	realLimit = limit

	realLimitPlusOne := realLimit + 1

	// var events []*ent.Event
	var eventInvitesRes []*model.EventInviteRes

	var stringIdsList []string

	for _, id := range idsList {
		stringIdsList = append(stringIdsList, strconv.Itoa(id))
	}

	var args []interface{}
	args = append(args, *userId) // add userId to args
	args = append(args, *userId)

	var params []string
	for _, id := range stringIdsList {
		// convert id to int and append to args
		intId, err := strconv.Atoi(id)
		if err != nil {
			return nil, err // handle error
		}
		args = append(args, intId)
		params = append(params, "?")
	}

	// join params with commas
	placeholders := strings.Join(params, ",")

	args = append(args, realLimitPlusOne)

	query := `
		select e.*, eu.invited_by, eu.admin, eu.creator from events e
		inner join event_users eu
	 		on (e.id = eu.event_id)
	 		and (eu.user_id = ?)
	 		and (eu.creator = false)
	 		and (eu.confirmed = false)

	 	inner join follows f
	 		on (f.user_id = eu.invited_by)
	 		and (f.follower_id = ?)
	 		and (f.valid = true)
	`

	if len(placeholders) > 0 {
		query += fmt.Sprintf("where e.id not in (%s) ", placeholders)
	}

	query += `
		order by eu.created_at DESC
		limit ?
	`

	res, err := r.client.QueryContext(ctx, query, args...)
	if err != nil {
		log.Println(err)
		return nil, err
	}

	for res.Next() {
		var id int
		var name string
		var description string
		var confirmed_count int
		var event_pics string
		var light_event_pics string
		var event_date time.Time
		var created_at time.Time
		var updated_at time.Time
		var coords schematype.Point
		var invited_by int
		var event_key string
		var event_nonce string
		var confirmed_hosts int
		var admin bool
		var creator bool
		var event_place string

		if err := res.Scan(
			&id,
			&name,
			&description,
			&confirmed_count,
			&event_pics,
			&event_date,
			&coords,
			&created_at,
			&updated_at,
			&light_event_pics,
			&event_key,
			&event_nonce,
			&confirmed_hosts,
			&event_place,
			&invited_by,
			&admin,
			&creator,
		); err != nil {
			// Check for a scan error.
			log.Println(err)
			return nil, err
		}

		var eventPics []string
		json.Unmarshal([]byte(event_pics), &eventPics)

		var lightEventPics []string
		json.Unmarshal([]byte(light_event_pics), &lightEventPics)

		event := ent.Event{
			ID:             id,
			Name:           name,
			Description:    description,
			ConfirmedCount: confirmed_count,
			ConfirmedHosts: confirmed_hosts,
			EventPics:      eventPics,
			LightEventPics: lightEventPics,
			EventDate:      event_date,
			EventPlace:     event_place,
			Coords:         &coords,
			CreatedAt:      created_at,
			UpdatedAt:      updated_at,
			EventKey:       event_key,
			EventNonce:     event_nonce,
		}

		invitedUserInfo := model.InvitedUserInfo{
			IsConfirmed: false,
			IsHost:      admin,
			IsCreator:   creator,
		}

		eventInviteRes := model.EventInviteRes{
			Event:           &event,
			InvitedByUserID: invited_by,
			InvitedUserInfo: &invitedUserInfo,
		}

		// events = append(events, &event)
		eventInvitesRes = append(eventInvitesRes, &eventInviteRes)
	}

	res.Close()

	if len(eventInvitesRes) < realLimit {
		realLimit = len(eventInvitesRes)
	}

	return &model.PaginatedEventResults{
		Events:  eventInvitesRes[0:realLimit],
		HasMore: len(eventInvitesRes) == realLimitPlusOne,
	}, nil

	// return eventInvitesRes, nil
}

// GetUserOtherEvents is the resolver for the getUserOtherEvents field.
func (r *queryResolver) GetUserOtherEvents(ctx context.Context, limit int, idsList []int) (*model.PaginatedEventResults, error) {
	userId, authErr := utils.IsAuth(ctx)
	if authErr != nil {
		return nil, authErr
	}

	realLimit := 8

	realLimit = limit

	realLimitPlusOne := realLimit + 1

	// var events []*ent.Event
	var eventInvitesRes []*model.EventInviteRes

	var stringIdsList []string

	for _, id := range idsList {
		stringIdsList = append(stringIdsList, strconv.Itoa(id))
	}

	var args []interface{}
	args = append(args, *userId) // add userId to args
	args = append(args, *userId)

	var params []string
	for _, id := range stringIdsList {
		// convert id to int and append to args
		intId, err := strconv.Atoi(id)
		if err != nil {
			return nil, err // handle error
		}
		args = append(args, intId)
		params = append(params, "?")
	}

	// join params with commas
	placeholders := strings.Join(params, ",")

	args = append(args, realLimitPlusOne)

	query := `
		select e.*, eu.invited_by, eu.admin, eu.creator from events e
		inner join event_users eu
	 		on (e.id = eu.event_id)
	 		and (eu.user_id = ?)
	 		and (eu.creator = false)
	 		and (eu.confirmed = false)

	 	left join follows f
		  on (f.user_id = eu.invited_by)
	 		and (f.follower_id = ?)

		where (f.user_id is null or f.valid = false)
	`

	if len(placeholders) > 0 {
		query += fmt.Sprintf("and e.id not in (%s) ", placeholders)
	}

	query += `
		order by eu.created_at DESC
		limit ?
	`

	res, err := r.client.QueryContext(ctx, query, args...)
	if err != nil {
		log.Println(err)
		return nil, err
	}

	for res.Next() {
		var id int
		var name string
		var description string
		var confirmed_count int
		var event_pics string
		var light_event_pics string
		var event_date time.Time
		var created_at time.Time
		var updated_at time.Time
		var coords schematype.Point
		var invited_by int
		var event_key string
		var event_nonce string
		var confirmed_hosts int
		var admin bool
		var creator bool
		var event_place string

		if err := res.Scan(
			&id,
			&name,
			&description,
			&confirmed_count,
			&event_pics,
			&event_date,
			&coords,
			&created_at,
			&updated_at,
			&light_event_pics,
			&event_key,
			&event_nonce,
			&confirmed_hosts,
			&event_place,
			&invited_by,
			&admin,
			&creator,
		); err != nil {
			// Check for a scan error.
			log.Println(err)
			return nil, err
		}

		var eventPics []string
		json.Unmarshal([]byte(event_pics), &eventPics)

		var lightEventPics []string
		json.Unmarshal([]byte(light_event_pics), &lightEventPics)

		event := ent.Event{
			ID:             id,
			Name:           name,
			Description:    description,
			ConfirmedCount: confirmed_count,
			ConfirmedHosts: confirmed_hosts,
			EventPics:      eventPics,
			LightEventPics: lightEventPics,
			EventDate:      event_date,
			EventPlace:     event_place,
			Coords:         &coords,
			CreatedAt:      created_at,
			UpdatedAt:      updated_at,
			EventKey:       event_key,
			EventNonce:     event_nonce,
		}

		invitedUserInfo := model.InvitedUserInfo{
			IsConfirmed: false,
			IsHost:      admin,
			IsCreator:   creator,
		}

		eventInviteRes := model.EventInviteRes{
			Event:           &event,
			InvitedByUserID: invited_by,
			InvitedUserInfo: &invitedUserInfo,
		}

		// events = append(events, &event)
		eventInvitesRes = append(eventInvitesRes, &eventInviteRes)
	}

	res.Close()

	if len(eventInvitesRes) < realLimit {
		realLimit = len(eventInvitesRes)
	}

	return &model.PaginatedEventResults{
		Events:  eventInvitesRes[0:realLimit],
		HasMore: len(eventInvitesRes) == realLimitPlusOne,
	}, nil

	// return eventInvitesRes, nil
}

// SeePass is the resolver for the seePass field.
func (r *queryResolver) SeePass(ctx context.Context, eventID int) (*string, error) {
	userId, authErr := utils.IsAuth(ctx)
	if authErr != nil {
		return nil, authErr
	}

	eventUser, err := r.client.EventUser.Query().
		Where(
			eventuser.And(
				eventuser.EventID(eventID),
				eventuser.UserID(*userId),
			),
		).
		Only(ctx)
	if err != nil {
		log.Printf("error while getting event user: %s", err)
		return nil, err
	}

	if !eventUser.Confirmed {
		return nil, fmt.Errorf("user has not confirmed")
	}

	event, err := r.client.Event.Query().
		Where(event.ID(eventID)).
		Only(ctx)
	if err != nil {
		return nil, err
	}

	keyChannel := make(chan awsParameterStore.KeysResGoroutine)
	nonceChannel := make(chan awsParameterStore.KeysResGoroutine)

	go awsParameterStore.GetEventKeyParameterGoroutine("Happ_events_e", keyChannel)
	go awsParameterStore.GetEventKeyParameterGoroutine("Happ_events_o", nonceChannel)

	keyRes, nonceRes := <-keyChannel, <-nonceChannel

	if keyRes.Error != nil {
		log.Printf("error while calling getEventKeyParameterGoroutine: %s", err)
		return nil, err
	}

	if nonceRes.Error != nil {
		log.Printf("error while calling getEventKeyParameterGoroutine: %s", err)
		return nil, err
	}

	keyBytes, nonceBytes := keyRes.Value, nonceRes.Value

	encryptedKey := event.EventKey
	encryptedNonce := event.EventNonce

	decodedEncryptedKey, err := base64.StdEncoding.DecodeString(encryptedKey)
	if err != nil {
		log.Printf("error while decoding encrypted key: %s", err)
		return nil, err
	}

	decodedEncryptedNonce, err := base64.StdEncoding.DecodeString(encryptedNonce)
	if err != nil {
		log.Printf("error while decoding encrypted nonce: %s", err)
		return nil, err
	}

	decryptedKey, err := AES_Encryption.Decrypt(decodedEncryptedKey, []byte(*keyBytes), []byte(*nonceBytes))
	if err != nil {
		log.Printf("error while decrypting key: %s", err)
		return nil, err
	}

	decryptedNonce, err := AES_Encryption.Decrypt(decodedEncryptedNonce, []byte(*keyBytes), []byte(*nonceBytes))
	if err != nil {
		log.Printf("error while decrypting nonce: %s", err)
		return nil, err
	}
	textToBeEncrypted := strconv.Itoa(*userId)

	cypherTextBytes, err := AES_Encryption.Encrypt([]byte(textToBeEncrypted), decryptedKey, decryptedNonce)
	if err != nil {
		log.Printf("error while creating cypher text nonce: %s", err)
		return nil, err
	}

	cypherText := base64.StdEncoding.EncodeToString(cypherTextBytes)

	return &cypherText, nil
}

// GetEventGuests is the resolver for the getEventGuests field.
func (r *queryResolver) GetEventGuests(ctx context.Context, eventID int, limit int, idsList []int) (*model.PaginatedEventUsersResults, error) {
	userId, authErr := utils.IsAuth(ctx)
	if authErr != nil {
		return nil, authErr
	}

	var realLimit int

	if len(idsList) == 0 {
		realLimit = 8
	} else {
		realLimit = 25
	}

	realLimit = limit

	realLimitPlusOne := realLimit + 1

	var users []*ent.User

	var stringIdsList []string

	for _, id := range idsList {
		stringIdsList = append(stringIdsList, strconv.Itoa(id))
	}

	var args []interface{}
	args = append(args, eventID) // add userId to args
	args = append(args, *userId)

	var params []string
	for _, id := range stringIdsList {
		// convert id to int and append to args
		intId, err := strconv.Atoi(id)
		if err != nil {
			return nil, err // handle error
		}
		args = append(args, intId)
		params = append(params, "?")
	}

	// join params with commas
	placeholders := strings.Join(params, ",")

	args = append(args, *userId)
	args = append(args, realLimitPlusOne)

	query := `
	SELECT u.*, f.user_id FROM users u

	INNER JOIN event_users eu ON eu.user_id = u.id AND eu.event_id = ? AND eu.confirmed = true AND eu.admin = false
	LEFT JOIN follows f ON f.user_id = u.id AND f.follower_id = ? AND f.valid = true

	WHERE eu.user_id IS NOT NULL
	`

	if len(placeholders) > 0 {
		query += fmt.Sprintf("AND u.id NOT IN (%s) ", placeholders)
	}

	query += `
		ORDER BY CASE WHEN f.user_id = ?  THEN 1 ELSE 2 END, f.user_id DESC
		LIMIT ?
	`

	res, err := r.client.QueryContext(ctx, query, args...)
	if err != nil {
		log.Println(err)
		return nil, err
	}

	for res.Next() {
		var id int
		var name string
		var username string
		var email string
		var fuid string
		// var birthday time.Time
		// var password string
		var created_at time.Time
		var updated_at time.Time
		var profile_pic string
		var user_id *int

		if err := res.Scan(
			&id,
			&name,
			&username,
			&email,
			// &birthday,
			// &password,
			&created_at,
			&updated_at,
			&profile_pic,
			&fuid,
			&user_id,
		); err != nil {
			// Check for a scan error.
			log.Println(err)
			return nil, err
		}

		event := ent.User{
			ID:       id,
			Name:     name,
			Username: username,
			Email:    email,
			// Birthday:   birthday,
			// Password:   password,
			CreatedAt:  created_at,
			UpdatedAt:  updated_at,
			ProfilePic: profile_pic,
			FUID:       fuid,
		}

		users = append(users, &event)
	}

	res.Close()

	if len(users) < realLimit {
		realLimit = len(users)
	}

	return &model.PaginatedEventUsersResults{
		Users:   users[0:realLimit],
		HasMore: len(users) == realLimitPlusOne,
	}, nil
}

// GetEventHosts is the resolver for the getEventHosts field.
func (r *queryResolver) GetEventHosts(ctx context.Context, eventID int, limit int, idsList []int) (*model.PaginatedEventUsersResults, error) {
	userId, authErr := utils.IsAuth(ctx)
	if authErr != nil {
		return nil, authErr
	}

	var realLimit int

	if len(idsList) == 0 {
		realLimit = 3
	} else {
		realLimit = 25
	}

	realLimitPlusOne := realLimit + 1

	var users []*ent.User

	var stringIdsList []string

	for _, id := range idsList {
		stringIdsList = append(stringIdsList, strconv.Itoa(id))
	}

	var args []interface{}
	args = append(args, eventID) // add userId to args
	args = append(args, *userId)

	var params []string
	for _, id := range stringIdsList {
		// convert id to int and append to args
		intId, err := strconv.Atoi(id)
		if err != nil {
			return nil, err // handle error
		}
		args = append(args, intId)
		params = append(params, "?")
	}

	// join params with commas
	placeholders := strings.Join(params, ",")

	args = append(args, *userId)
	args = append(args, realLimitPlusOne)

	query := `
	SELECT u.*, f.user_id FROM users u

	INNER JOIN event_users eu ON eu.user_id = u.id AND eu.event_id = ? AND eu.confirmed = true AND eu.admin = true
	LEFT JOIN follows f ON f.user_id = u.id AND f.follower_id = ? AND f.valid = true

	WHERE eu.user_id IS NOT NULL
	`

	if len(placeholders) > 0 {
		query += fmt.Sprintf("AND u.id NOT IN (%s) ", placeholders)
	}

	query += `
		ORDER BY CASE WHEN f.user_id = ?  THEN 1 ELSE 2 END, f.user_id DESC
		LIMIT ?
	`

	res, err := r.client.QueryContext(ctx, query, args...)
	if err != nil {
		log.Println(err)
		return nil, err
	}

	for res.Next() {
		var id int
		var name string
		var username string
		var email string
		var fuid string
		// var birthday time.Time
		// var password string
		var created_at time.Time
		var updated_at time.Time
		var profile_pic string
		var user_id *int

		if err := res.Scan(
			&id,
			&name,
			&username,
			&email,
			// &birthday,
			// &password,
			&created_at,
			&updated_at,
			&profile_pic,
			&fuid,
			&user_id,
		); err != nil {
			// Check for a scan error.
			log.Println(err)
			return nil, err
		}

		event := ent.User{
			ID:       id,
			Name:     name,
			Username: username,
			Email:    email,
			// Birthday:   birthday,
			// Password:   password,
			CreatedAt:  created_at,
			UpdatedAt:  updated_at,
			ProfilePic: profile_pic,
			FUID:       fuid,
		}

		users = append(users, &event)
	}

	res.Close()

	if len(users) < realLimit {
		realLimit = len(users)
	}

	return &model.PaginatedEventUsersResults{
		Users:   users[0:realLimit],
		HasMore: len(users) == realLimitPlusOne,
	}, nil
}

// SearchForUsersToAddAsGuests is the resolver for the searchForUsersToAddAsGuests field.
func (r *queryResolver) SearchForUsersToAddAsGuests(ctx context.Context, search string, eventID int) ([]*ent.User, error) {
	// Get the list of invited user IDs for the event
	invitedIDs, err := r.client.EventUser.
		Query().
		Where(eventuser.EventID(eventID)).
		Select(eventuser.FieldUserID).
		Ints(ctx)
	if err != nil {
		return nil, err
	}

	trimmedSearch := strings.TrimSpace(search)

	// Search for users using Meilisearch
	var users []*ent.User
	res, err := meilisearchUtils.GetUsersFromMeili(trimmedSearch, invitedIDs)
	if err != nil {
		// return nil, err

		// or show empty array of users
		return users, nil
	}

	if len(res) == 0 {
		return users, nil
	}

	for _, user := range res {
		userMap := user.(map[string]interface{})
		users = append(
			users,
			&ent.User{
				ID:         int(userMap["id"].(float64)),
				Username:   userMap["username"].(string),
				Name:       userMap["name"].(string),
				ProfilePic: userMap["profilePic"].(string),
			},
		)
	}

	return users, nil
}

// SearchLocation is the resolver for the searchLocation field.
func (r *queryResolver) SearchLocation(ctx context.Context, search string) ([]*model.LocationAutoCompletePrediction, error) {
	res, err := googleMapsUtils.LocationAutocomplete(ctx, search)
	if err != nil {
		log.Printf("Error while calling LocationAutocomplete(): %s", err)
		return nil, err
	}

	var autocompletePrediction []*model.LocationAutoCompletePrediction

	for _, prediction := range *res {
		predictionVal := &model.LocationAutoCompletePrediction{
			PlaceID:     prediction.PlaceID,
			Description: prediction.Description,
		}
		autocompletePrediction = append(autocompletePrediction, predictionVal)
	}

	return autocompletePrediction, nil
}

// LocationDetails is the resolver for the locationDetails field.
func (r *queryResolver) LocationDetails(ctx context.Context, placeID string) (*model.Coordinates, error) {
	res, err := googleMapsUtils.LocationDetails(ctx, placeID)
	if err != nil {
		log.Printf("Error while calling LocationDetails(): %s", err)
		return nil, err
	}

	geocodingRes := *res

	coords := &model.Coordinates{
		Latitude:  geocodingRes[0].Geometry.Location.Lat,
		Longitude: geocodingRes[0].Geometry.Location.Lng,
	}

	return coords, nil
}

// LocationDetailsFromCoords is the resolver for the locationDetailsFromCoords field.
func (r *queryResolver) LocationDetailsFromCoords(ctx context.Context, coords model.CoordinatesInput) (string, error) {
	res, err := googleMapsUtils.LocationDetailsFromCoords(ctx, coords)
	if err != nil {
		log.Printf("Error while calling LocationDetails(): %s", err)
		return "", err
	}

	geocodingRes := *res

	name := ""
	for _, result := range geocodingRes {
		hasPlusCode := false
		if len(result.AddressComponents) > 0 {
			for _, t := range result.AddressComponents[0].Types {
				if t == "plus_code" {
					hasPlusCode = true
					break
				}
			}
		}
		if !hasPlusCode {
			name = result.FormattedAddress
			break
		}
	}

	return name, nil
}

// MutualFriends is the resolver for the mutualFriends field.
func (r *queryResolver) MutualFriends(ctx context.Context, id int, limit int, idsList []int) (*model.PaginatedEventUsersResults, error) {
	userId, authErr := utils.IsAuth(ctx)
	if authErr != nil {
		return nil, authErr
	}

	realLimit := 20

	realLimitPlusOne := realLimit + 1

	var users []*ent.User

	var stringIdsList []string

	for _, id := range idsList {
		stringIdsList = append(stringIdsList, strconv.Itoa(id))
	}

	var args []interface{}
	args = append(args, *userId)
	args = append(args, id)
	args = append(args, *userId)

	args = append(args, *userId)
	args = append(args, id)

	var params []string
	for _, id := range stringIdsList {
		// convert id to int and append to args
		intId, err := strconv.Atoi(id)
		if err != nil {
			return nil, err // handle error
		}
		args = append(args, intId)
		params = append(params, "?")
	}

	// join params with commas
	placeholders := strings.Join(params, ",")

	args = append(args, realLimitPlusOne)

	query := `
	SELECT u.*, IF(f3.follower_id IS NOT NULL, 1, 0) follows_current_user, f1.created_at follow_created_at FROM users u

	INNER JOIN follows f1
	ON f1.user_id = u.id
	AND f1.follower_id = ? 
	AND f1.valid = true

	INNER JOIN follows f2
	ON f2.user_id = u.id
	AND f2.follower_id = ? 
	AND f2.valid = true

	LEFT JOIN follows f3
	ON f3.user_id = ?
	AND f3.follower_id = u.id
	AND f3.valid = true

	WHERE u.id NOT IN (?,?) 
	`

	if len(placeholders) > 0 {
		query += fmt.Sprintf("AND u.id NOT IN (%s) ", placeholders)
	}

	query += `
		ORDER BY follows_current_user DESC, follow_created_at DESC
		LIMIT ?
	`

	res, err := r.client.QueryContext(ctx, query, args...)
	if err != nil {
		log.Println(err)
		return nil, err
	}

	for res.Next() {
		var id int
		var name string
		var username string
		var email string
		var fuid string
		var created_at time.Time
		var updated_at time.Time
		var profile_pic string
		var follows_current_user bool
		var follow_created_at time.Time

		if err := res.Scan(
			&id,
			&name,
			&username,
			&email,
			&created_at,
			&updated_at,
			&profile_pic,
			&fuid,
			&follows_current_user,
			&follow_created_at,
		); err != nil {
			log.Println(err)
			return nil, err
		}

		event := ent.User{
			ID:         id,
			Name:       name,
			Username:   username,
			Email:      email,
			CreatedAt:  created_at,
			UpdatedAt:  updated_at,
			ProfilePic: profile_pic,
			FUID:       fuid,
		}

		users = append(users, &event)
	}

	res.Close()

	if len(users) < realLimit {
		realLimit = len(users)
	}

	return &model.PaginatedEventUsersResults{
		Users:   users[0:realLimit],
		HasMore: len(users) == realLimitPlusOne,
	}, nil
}

// GetFollowState is the resolver for the getFollowState field.
func (r *queryResolver) GetFollowState(ctx context.Context, id int) (bool, error) {
	userId, authErr := utils.IsAuth(ctx)
	if authErr != nil {
		return false, authErr
	}

	res, err := r.client.Follow.Query().
		Where(
			follow.And(
				follow.FollowerID(*userId),
				follow.UserID(id),
			),
		).
		Select(follow.FieldValid).
		Bool(ctx)
	if err == nil {
		return res, nil
	}

	return false, nil
}

// MyFriends is the resolver for the myFriends field.
func (r *queryResolver) MyFriends(ctx context.Context, limit int, idsList []int) (*model.PaginatedEventUsersResults, error) {
	userId, authErr := utils.IsAuth(ctx)
	if authErr != nil {
		return nil, authErr
	}

	realLimit := 20

	realLimitPlusOne := realLimit + 1

	var users []*ent.User

	var stringIdsList []string

	for _, id := range idsList {
		stringIdsList = append(stringIdsList, strconv.Itoa(id))
	}

	var args []interface{}
	args = append(args, *userId)

	args = append(args, *userId)

	args = append(args, *userId)

	var params []string
	for _, id := range stringIdsList {
		// convert id to int and append to args
		intId, err := strconv.Atoi(id)
		if err != nil {
			return nil, err // handle error
		}
		args = append(args, intId)
		params = append(params, "?")
	}

	// join params with commas
	placeholders := strings.Join(params, ",")

	args = append(args, realLimitPlusOne)

	query := `
	SELECT u.*, IF(f3.follower_id IS NOT NULL, 1, 0) follows_current_user, f2.created_at follow_created_at FROM users u

	INNER JOIN follows f2
	ON f2.user_id = u.id
	AND f2.follower_id = ?
	AND f2.valid = true

	LEFT JOIN follows f3
	ON f3.user_id = ?
	AND f3.follower_id = u.id
	AND f3.valid = true

	AND u.id != ?
	`

	if len(placeholders) > 0 {
		query += fmt.Sprintf("AND u.id NOT IN (%s) ", placeholders)
	}

	query += `
		ORDER BY follows_current_user DESC, follow_created_at DESC
		LIMIT ?
	`

	res, err := r.client.QueryContext(ctx, query, args...)
	if err != nil {
		log.Println(err)
		return nil, err
	}

	for res.Next() {
		var id int
		var name string
		var username string
		var email string
		var fuid string
		var created_at time.Time
		var updated_at time.Time
		var profile_pic string
		var follows_current_user bool
		var follows_created_at time.Time

		if err := res.Scan(
			&id,
			&name,
			&username,
			&email,
			&created_at,
			&updated_at,
			&profile_pic,
			&fuid,
			&follows_current_user,
			&follows_created_at,
		); err != nil {
			log.Println(err)
			return nil, err
		}

		event := ent.User{
			ID:         id,
			Name:       name,
			Username:   username,
			Email:      email,
			CreatedAt:  created_at,
			UpdatedAt:  updated_at,
			ProfilePic: profile_pic,
			FUID:       fuid,
		}

		users = append(users, &event)
	}

	res.Close()

	if len(users) < realLimit {
		realLimit = len(users)
	}

	return &model.PaginatedEventUsersResults{
		Users:   users[0:realLimit],
		HasMore: len(users) == realLimitPlusOne,
	}, nil
}

// AddedMe is the resolver for the addedMe field.
func (r *queryResolver) AddedMe(ctx context.Context, limit int, idsList []int) (*model.PaginatedEventUsersResults, error) {
	userId, authErr := utils.IsAuth(ctx)
	if authErr != nil {
		return nil, authErr
	}

	realLimit := 20

	realLimitPlusOne := realLimit + 1

	var users []*ent.User

	var stringIdsList []string

	for _, id := range idsList {
		stringIdsList = append(stringIdsList, strconv.Itoa(id))
	}

	var args []interface{}
	args = append(args, *userId)

	args = append(args, *userId)

	var params []string
	for _, id := range stringIdsList {
		// convert id to int and append to args
		intId, err := strconv.Atoi(id)
		if err != nil {
			return nil, err // handle error
		}
		args = append(args, intId)
		params = append(params, "?")
	}

	// join params with commas
	placeholders := strings.Join(params, ",")

	args = append(args, realLimitPlusOne)

	query := `
	SELECT u.*, f.created_at follow_created_at FROM users u

	INNER JOIN follows f
	ON f.user_id = ?
	AND f.follower_id = u.id
	AND f.valid = true

	AND u.id != ?
	`

	if len(placeholders) > 0 {
		query += fmt.Sprintf("AND u.id NOT IN (%s) ", placeholders)
	}

	query += `
		ORDER BY follow_created_at DESC
		LIMIT ?
	`

	res, err := r.client.QueryContext(ctx, query, args...)
	if err != nil {
		log.Println(err)
		return nil, err
	}

	for res.Next() {
		var id int
		var name string
		var username string
		var email string
		var fuid string
		var created_at time.Time
		var updated_at time.Time
		var profile_pic string
		var follow_created_at time.Time

		if err := res.Scan(
			&id,
			&name,
			&username,
			&email,
			&created_at,
			&updated_at,
			&profile_pic,
			&fuid,
			&follow_created_at,
		); err != nil {
			log.Println(err)
			return nil, err
		}

		user := ent.User{
			ID:         id,
			Name:       name,
			Username:   username,
			Email:      email,
			CreatedAt:  created_at,
			UpdatedAt:  updated_at,
			ProfilePic: profile_pic,
			FUID:       fuid,
			// FollowState: followState,
			// followState
		}

		users = append(users, &user)
	}

	res.Close()

	if len(users) < realLimit {
		realLimit = len(users)
	}

	return &model.PaginatedEventUsersResults{
		Users:   users[0:realLimit],
		HasMore: len(users) == realLimitPlusOne,
	}, nil
}

// FollowState is the resolver for the followState field.
func (r *userResolver) FollowState(ctx context.Context, obj *ent.User) (bool, error) {
	userId, err := utils.GetUserIdFromHeader(ctx)
	if err != nil {
		return false, nil
	}

	if *userId == obj.ID {
		return true, nil
	}

	return dataloaders.GetFollowState(ctx, strconv.Itoa(obj.ID))
}

// CreatedAt is the resolver for the createdAt field.
func (r *userResolver) CreatedAt(ctx context.Context, obj *ent.User) (string, error) {
	createdAtNano := obj.CreatedAt.UnixNano()

	createdAtmillis := createdAtNano / 1000000

	createdAtTime := int(createdAtmillis)

	createdAt := strconv.Itoa(createdAtTime)

	return createdAt, nil
}

// UpdatedAt is the resolver for the updatedAt field.
func (r *userResolver) UpdatedAt(ctx context.Context, obj *ent.User) (string, error) {
	updatedAtNano := obj.UpdatedAt.UnixNano()

	updatedAtmillis := updatedAtNano / 1000000

	updatedAtTime := int(updatedAtmillis)

	updatedAt := strconv.Itoa(updatedAtTime)

	return updatedAt, nil
}

// Event returns generated.EventResolver implementation.
func (r *Resolver) Event() generated.EventResolver { return &eventResolver{r} }

// EventInviteRes returns generated.EventInviteResResolver implementation.
func (r *Resolver) EventInviteRes() generated.EventInviteResResolver {
	return &eventInviteResResolver{r}
}

// Mutation returns generated.MutationResolver implementation.
func (r *Resolver) Mutation() generated.MutationResolver { return &mutationResolver{r} }

// Query returns generated.QueryResolver implementation.
func (r *Resolver) Query() generated.QueryResolver { return &queryResolver{r} }

// User returns generated.UserResolver implementation.
func (r *Resolver) User() generated.UserResolver { return &userResolver{r} }

type eventResolver struct{ *Resolver }
type eventInviteResResolver struct{ *Resolver }
type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
type userResolver struct{ *Resolver }
