package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.29

import (
	"bytes"
	"context"
	"encoding/base64"
	"encoding/json"
	"fmt"
	"happ/ent"
	"happ/ent/event"
	"happ/ent/eventuser"
	"happ/ent/follow"
	"happ/ent/schema/schematype"
	"happ/ent/user"
	"happ/graph/dataloaders"
	"happ/graph/generated"
	"happ/graph/model"
	"happ/utils"
	AES_Encryption "happ/utils/AES-GCM_Encryption"
	awsParameterStore "happ/utils/aws/awsParams"
	"happ/utils/aws/awsS3"
	firebaseUtils "happ/utils/firebase"
	"happ/utils/inputHandlers"
	meilisearchUtils "happ/utils/meilisearch"
	"happ/utils/newEventUtils"
	"happ/utils/notifications"
	redisUtils "happ/utils/redis"
	"io"
	"log"
	"math/rand"
	"strconv"
	"strings"
	"time"

	"github.com/google/uuid"
)

// EventDate is the resolver for the eventDate field.
func (r *eventResolver) EventDate(ctx context.Context, obj *ent.Event) (string, error) {
	EventDateNano := obj.EventDate.UnixNano()

	EventDatemillis := EventDateNano / 1000000

	EventDateTime := int(EventDatemillis)

	EventDate := strconv.Itoa(EventDateTime)

	return EventDate, nil
}

// CreatedAt is the resolver for the createdAt field.
func (r *eventResolver) CreatedAt(ctx context.Context, obj *ent.Event) (string, error) {
	createdAtNano := obj.CreatedAt.UnixNano()

	createdAtmillis := createdAtNano / 1000000

	createdAtTime := int(createdAtmillis)

	createdAt := strconv.Itoa(createdAtTime)

	return createdAt, nil
}

// UpdatedAt is the resolver for the updatedAt field.
func (r *eventResolver) UpdatedAt(ctx context.Context, obj *ent.Event) (string, error) {
	updatedAtNano := obj.UpdatedAt.UnixNano()

	updatedAtmillis := updatedAtNano / 1000000

	updatedAtTime := int(updatedAtmillis)

	updatedAt := strconv.Itoa(updatedAtTime)

	return updatedAt, nil
}

// Coords is the resolver for the coords field.
func (r *eventResolver) Coords(ctx context.Context, obj *ent.Event) (*model.Coordinates, error) {
	return &model.Coordinates{
		Latitude:  obj.Coords[0],
		Longitude: obj.Coords[1],
	}, nil
}

// InvitedBy is the resolver for the invitedBy field.
func (r *eventInviteResResolver) InvitedBy(ctx context.Context, obj *model.EventInviteRes) (*ent.User, error) {
	return dataloaders.GetUser(ctx, strconv.Itoa(obj.InvitedByUserID))
}

// Friends is the resolver for the friends field.
func (r *eventInviteResResolver) Friends(ctx context.Context, obj *model.EventInviteRes) ([]*ent.User, error) {
	var users []*ent.User
	userId, err := utils.GetUserIdFromHeader(ctx)
	if err != nil {
		return users, nil
	}

	// QUERY MADE BY CHAT GPT
	res, _ := r.client.QueryContext(ctx, `
		SELECT u.*, f.user_id FROM users u

		LEFT JOIN follows f ON f.user_id = u.id AND f.follower_id = `+strconv.Itoa(*userId)+` AND f.valid = true
		LEFT JOIN event_users eu ON eu.user_id = u.id AND eu.event_id = `+strconv.Itoa(obj.Event.ID)+` AND eu.confirmed = true

		WHERE eu.user_id IS NOT NULL

		ORDER BY CASE WHEN f.user_id = `+strconv.Itoa(*userId)+` THEN 1 ELSE 2 END, f.user_id DESC

		LIMIT 3;
	`)

	for res.Next() {
		var id int
		var name string
		var username string
		var email string
		var fuid string
		// var birthday time.Time
		// var password string
		var created_at time.Time
		var updated_at time.Time
		var profile_pic string
		var user_id *int

		if err := res.Scan(
			&id,
			&name,
			&username,
			&email,
			// &birthday,
			// &password,
			&created_at,
			&updated_at,
			&profile_pic,
			&fuid,
			&user_id,
		); err != nil {
			// Check for a scan error.
			// Query rows will be closed with defer.
			log.Fatal(err)
		}

		event := ent.User{
			ID:       id,
			Name:     name,
			Username: username,
			Email:    email,
			// Birthday:   birthday,
			// Password:   password,
			CreatedAt:  created_at,
			UpdatedAt:  updated_at,
			ProfilePic: profile_pic,
			FUID:       fuid,
		}

		// events = append(events, &event)
		users = append(users, &event)
	}

	return users, nil
}

// SignIn is the resolver for the signIn field.
func (r *mutationResolver) SignIn(ctx context.Context, input model.SignInInput) (*model.SignInResponse, error) {
	// Verify token
	token, err := firebaseUtils.AuthClient.VerifyIDToken(ctx, input.Token)
	if err != nil {
		return nil, fmt.Errorf("error verifying id token: %v", err)
	}

	fmt.Println(token.Claims["user_id"])
	fmt.Println(token.Claims["email"])
	// fmt.Println(reflect.TypeOf(token.Claims["email"]))
	fmt.Println(token.Claims["name"])
	fmt.Println(token.Claims["picture"])
	fmt.Println(token.UID)
	fmt.Println(token.Claims)
	fmt.Println(token.Claims["id"])
	// fmt.Println(reflect.TypeOf(token.Claims["id"]))
	fmt.Println(token.Claims["username"])

	var exists bool

	userToSign, err := r.client.User.Query().
		Where(
			user.FUID(token.UID),
		).
		Only(ctx)
	if err != nil {
		// exists = false
		if ent.IsNotFound(err) {
			exists = false
		} else {
			return nil, fmt.Errorf("error querying user: %v", err)
		}
	} else {
		exists = true
	}

	if exists {
		value := false
		return &model.SignInResponse{
			User:  userToSign,
			IsNew: &value,
		}, nil
	}

	var name string

	var username string

	var authCode *string

	if token.Claims["name"] != nil {

		name = token.Claims["name"].(string)
		if len(name) > 30 {
			name = name[:30]
		}

		preUsername := inputHandlers.ProcessString(name)

		if len(preUsername) > 25 {
			preUsername = preUsername[:25]
		}

		username = preUsername

	} else {

		if input.Provider == "APPLE" {
			name = input.AppleData.Name
			if len(name) > 30 {
				name = name[:30]
			}

			// preUsername := strings.ToLower(strings.ReplaceAll(name, " ", ""))

			// reg := regexp.MustCompile("[^a-z0-9.]")
			// preUsername = reg.ReplaceAllString(name, "")
			preUsername := inputHandlers.ProcessString(name)

			if len(preUsername) > 25 {
				preUsername = preUsername[:25]
			}

			username = preUsername
		} else {
			rand.Seed(time.Now().UnixNano())
			randomNumber := rand.Int63n(900000000000) + 100000000000

			username = "user" + strconv.FormatInt(randomNumber, 10)
			name = username
		}

	}

	email := token.Claims["email"].(string)

	picture, ok := token.Claims["picture"].(string)
	if !ok {
		picture = "https://d3pvchlba3rmqp.cloudfront.net/userProfilePics/blueLobster.jpg"
	}

	fmt.Println(username)

	newUser, err := r.client.User.Create().
		SetFUID(token.UID).
		SetName(name).
		SetUsername(username).
		SetEmail(email).
		SetProfilePic(picture).
		Save(ctx)
	if err != nil {
		if ent.IsConstraintError(err) {
			rand.Seed(time.Now().UnixNano())
			randomNumber := rand.Int63n(900000000000) + 100000000000

			username = "user" + strconv.FormatInt(randomNumber, 10)

			newUser, err = r.client.User.Create().
				SetFUID(token.UID).
				SetName(name).
				SetUsername(username).
				SetEmail(email).
				SetProfilePic(picture).
				Save(ctx)
			if err != nil {
				return nil, fmt.Errorf("could not create user")
			}

		} else {
			return nil, fmt.Errorf("could not create user")
		}
	}

	fmt.Println(newUser)

	rollback := false
	rollbackMeilisearchUserToo := false
	defer func() {
		if rollback {
			_, err := r.client.User.Delete().Where(user.ID(newUser.ID)).Exec(ctx)
			if err != nil {
				fmt.Printf("Failed to delete user after custom claims error: %v\n", err)
			}

			if rollbackMeilisearchUserToo {
				ok := meilisearchUtils.RemoveUserFromMeili(newUser.ID)
				if !ok {
					fmt.Printf("Failed to delete user from meilisearch: %v\n", err)
				}
			}
		}
	}()

	res := meilisearchUtils.AddUserToMeili(newUser)
	if !res {
		rollback = true
		return nil, fmt.Errorf("error creating meilisearch user: %v", err)
	}

	if input.Provider == "APPLE" {
		authCode = &input.AppleData.AuthorizationCode
	}

	claims := map[string]interface{}{
		"id":                     newUser.ID,
		"picture":                picture,
		"username":               username,
		"name":                   name,
		"appleAuthorizationCode": authCode,
	}
	err = firebaseUtils.AuthClient.SetCustomUserClaims(ctx, token.UID, claims)
	if err != nil {
		rollbackMeilisearchUserToo = true
		rollback = true
		return nil, fmt.Errorf("error setting custom claims: %v", err)
	}

	fmt.Println(newUser)

	value := true

	return &model.SignInResponse{
		User:  newUser,
		IsNew: &value,
	}, nil
}

// SignOut is the resolver for the signOut field.
func (r *mutationResolver) SignOut(ctx context.Context, token string) (bool, error) {
	userId, err := utils.IsAuth(ctx)

	if err == nil {
		redisUtils.DeleteTokenFromRedis("" + strconv.Itoa(*userId) + "_" + token)
	}

	return true, nil
}

// AddOrRemoveUser is the resolver for the addOrRemoveUser field.
func (r *mutationResolver) AddOrRemoveUser(ctx context.Context, followUserID int, isFollow bool) (*model.AddResponse, error) {
	// passing current userId as a header is a bad idea because an attacker can impersonificate a user
	// use jwt access token and extract user id from token
	// if it fails then get refresh token and return both access and refresh tokens and retry operations
	// it will not log user out because since refresh token has a long duration
	// and tokens are refreshed each time user opens app
	// then if user is logged in it should stay logged in
	userId, authErr := utils.IsAuth(ctx)
	if authErr != nil {
		return nil, authErr
	}

	// fmt.Println("aaaaa")

	// userId, _ := utils.GetUserIdFromHeader(ctx)

	// when user follows for first time create a "valid" row
	// when user follows upsert follow and make it valid (just flip the valid value)
	// when user unfollows make it invalid

	// current user that is following is always followerId
	// if follow fails then dont create friendship

	if isFollow {
		err := r.client.Follow.Create().
			SetFollowerID(*userId).
			SetUserID(followUserID).
			SetValid(true).
			OnConflict().
			SetValid(true).
			Exec(ctx)
		if err != nil {
			// if unchanged is true then ignore isFriend
			// if unchanged is true then make isFriend false
			// if unchaged is true value is 0
			return &model.AddResponse{
				Value:     0,
				Unchanged: true,
			}, nil
		}

		res := meilisearchUtils.AddFollowToMeili(*userId, followUserID)
		if !res {
			r.client.Follow.Update().
				SetValid(false).
				Where(
					follow.And(
						follow.FollowerID(*userId),
						follow.UserID(followUserID),
					),
				).
				Save(ctx)

			return &model.AddResponse{
				Value:     0,
				Unchanged: true,
			}, nil
		}

		go func() {
			userName, err := r.client.User.Query().
				Where(
					user.ID(*userId),
				).
				Select(user.FieldName).
				String(ctx)
			if err == nil {
				notifications.SendPushNotifications(r.client, followUserID, "Happ", userName+" has added you as a friend!")
			}
		}()

		return &model.AddResponse{
			Value:     1,
			Unchanged: false,
		}, nil
	}

	err := r.client.Follow.Create().
		SetFollowerID(*userId).
		SetUserID(followUserID).
		SetValid(false).
		OnConflict().
		SetValid(false).
		Exec(ctx)
	if err != nil {
		return &model.AddResponse{
			Value:     0,
			Unchanged: true,
		}, nil
	}

	res := meilisearchUtils.RemoveFollowToMeili(*userId, followUserID)
	if !res {
		_, _ = r.client.Follow.Update().
			Where(
				follow.And(
					follow.FollowerID(*userId),
					follow.UserID(followUserID),
				),
			).
			SetValid(true). // asume user was following before
			Save(ctx)

		return &model.AddResponse{
			Value:     0,
			Unchanged: true,
		}, nil
	}

	return &model.AddResponse{
		Value:     -1,
		Unchanged: false,
	}, nil
}

// NewEvent is the resolver for the newEvent field.
func (r *mutationResolver) NewEvent(ctx context.Context, input model.NewEventInput) (*model.CreateEventResponse, error) {
	userId, authErr := utils.IsAuth(ctx)
	if authErr != nil {
		return nil, authErr
	}

	var eventPics []string
	var lightEventPics []string

	// User creates Event
	// user gets

	// FOR GETTING BOTH NONCE AND KEY, DECODE AND THEN DECRYPT

	key, nonce, err := newEventUtils.CreateEventKeys()
	if err != nil {
		fmt.Printf("Error while creating keys: %s", err)
		// return error could not create event
		return nil, fmt.Errorf("could not create event, try again later")
	}

	for i := 0; i < len(input.EventPics); i++ { //i, picture := range input.EventPics {
		content, err := io.ReadAll(input.EventPics[i].File)
		if err != nil {
			// could not read file #i
			return nil, fmt.Errorf("could not read picture #%s", strconv.Itoa(i))
		}

		uuid := uuid.New()
		uuidString := uuid.String()
		key := "eventPictures/" + strconv.Itoa(i) + "-" + uuidString + ".jpg"

		eventPics = append(eventPics, "https://d3pvchlba3rmqp.cloudfront.net/"+key)

		file := bytes.NewReader(content)
		uploadRes := awsS3.UploadToS3(key, file)
		if !uploadRes {
			// return error could not create event try again later
			return nil, fmt.Errorf("could not create event, try again later")
		}
	}

	for i := 0; i < len(input.EventPicsLight); i++ {
		content, err := io.ReadAll(input.EventPicsLight[i].File)
		if err != nil {
			// could not read file #i
			return nil, fmt.Errorf("could not read picture #%s", strconv.Itoa(i))
		}

		uuid := uuid.New()
		uuidString := uuid.String()
		key := "lightEventPictures/" + strconv.Itoa(i) + "-" + uuidString + ".jpg"

		lightEventPics = append(lightEventPics, "https://d3pvchlba3rmqp.cloudfront.net/"+key)

		file := bytes.NewReader(content)
		uploadRes := awsS3.UploadToS3(key, file)
		if !uploadRes {
			// return error could not create event try again later
			return nil, fmt.Errorf("could not create event, try again later")
		}
	}

	msInt, _ := strconv.ParseInt(input.EventDate, 10, 64)
	eventDate := time.Unix(0, msInt*int64(time.Millisecond))

	coords := &schematype.Point{
		input.Latitude,
		input.Longitude,
	}

	event, err := r.client.Event.Create().
		SetName(input.Name).
		SetDescription(input.Description).
		SetEventPics(eventPics).
		SetEventDate(eventDate).
		SetLightEventPics(lightEventPics).
		SetEventPlace(input.EventPlace).
		SetCoords(coords).
		SetEventKey(*key).
		SetEventNonce(*nonce).
		Save(ctx)
	if err != nil {
		fmt.Println(err)
		// return error could not create event
		return nil, fmt.Errorf("could not create event, try again later")
	}

	_, eventUserErr := r.client.EventUser.Create().
		SetEventID(event.ID).
		SetUserID(*userId).
		SetAdmin(true).
		SetCreator(true).
		SetConfirmed(true).
		SetInvitedBy(*userId).
		Save(ctx)
	if eventUserErr != nil {
		_ = r.client.Event.DeleteOne(event).Exec(ctx)
		return nil, fmt.Errorf("could not create event, try again later")
	}

	fmt.Println(event)

	return &model.CreateEventResponse{
		Event: event,
		// Errors: &model.ErrorResponse{}[]
	}, nil
}

// InviteGuestsAndOrganizers is the resolver for the inviteGuestsAndOrganizers field.
func (r *mutationResolver) InviteGuestsAndOrganizers(ctx context.Context, guests []int, organizers []int, eventID int) (bool, error) {
	currentUserID, authErr := utils.IsAuth(ctx)
	if authErr != nil {
		return false, authErr
	}

	// bulk := make([]*ent.EventUserCreate, len(guests)+len(organizers))
	guestsBulk := make([]*ent.EventUserCreate, len(guests))
	organizersBulk := make([]*ent.EventUserCreate, len(organizers))

	userIds := make([]int, len(guests)+len(organizers))

	// Copy elements from array1 and array2 into the joinedArray
	copy(userIds[:len(guests)], guests)
	copy(userIds[len(organizers):], organizers)

	for i, userId := range guests {
		guestsBulk[i] = r.client.EventUser.Create().
			SetEventID(eventID).
			SetUserID(userId).
			SetInvitedBy(*currentUserID).
			SetAdmin(false)
	}

	for i, userId := range organizers {
		organizersBulk[i] = r.client.EventUser.Create().
			SetEventID(eventID).
			SetUserID(userId).
			SetInvitedBy(*currentUserID).
			SetAdmin(true)
	}

	bulk := append(guestsBulk, organizersBulk...)

	_, err := r.client.EventUser.CreateBulk(bulk...).Save(ctx)
	if err != nil {
		return false, nil
	}

	go func() {
		userName, err := r.client.User.Query().
			Where(
				user.ID(*currentUserID),
			).
			Select(user.FieldName).
			String(ctx)
		if err == nil {
			eventName, err := r.client.Event.Query().
				Where(
					event.ID(eventID),
				).
				Select(event.FieldName).
				String(ctx)
			if err == nil {
				notifications.SendManyPushNotifications(r.client, userIds, "Happ", userName+" has invited you to "+eventName)
			}
		}
	}()

	return true, nil
}

// AcceptInvitation is the resolver for the acceptInvitation field.
func (r *mutationResolver) AcceptInvitation(ctx context.Context, eventID int) (*model.AcceptInvitationResponse, error) {
	// WHEN USER CREATES EVENT (QR)
	// a key and nonce are generated, encrypted and saved in the database.

	// ACCEPT INVITATION FLOW (ONLINE METHOD)
	// User accepts invitation
	// `confirmed` row in event_users flips to true
	// server sends qr code to client (qr code has encrypted userID)
	// client saves it to local storage

	// (when read by organizer)
	// Organizer decode QR code and send encrypted string to server where it will be decrypted.
	// Server then sends response to organizer if user was accepted or not (do it in less than 1 second)

	userId, authErr := utils.IsAuth(ctx)
	if authErr != nil {
		return nil, authErr
	}

	eventUser, err := r.client.EventUser.Query().
		Where(
			eventuser.And(
				eventuser.EventID(eventID),
				eventuser.UserID(*userId),
			),
		).
		Only(ctx)
	if err != nil {
		fmt.Printf("error while getting event user: %s", err)
		return nil, err
	}

	if eventUser.Confirmed {
		return nil, fmt.Errorf("user has is confirmed")
	}

	thisEvent, err := r.client.Event.Query().
		Where(event.ID(eventID)).
		Only(ctx)
	if err != nil {
		return nil, err
	}

	tx, err := r.client.Tx(ctx)
	if err != nil {
		return nil, err
	}

	_, err = tx.EventUser.Update().
		Where(
			eventuser.And(
				eventuser.EventID(eventID),
				eventuser.UserID(*userId),
			),
		).
		SetConfirmed(true).
		Save(ctx)
	if err != nil {
		fmt.Printf("error while updating event user: %s", err)
		if rerr := tx.Rollback(); rerr != nil {
			err = fmt.Errorf("%w: %v", err, rerr)
			return nil, err
		}
		return nil, err
	}

	if eventUser.Admin {
		_, err = tx.Event.Update().
			Where(event.ID(eventID)).
			AddConfirmedCount(1).
			AddConfirmedHosts(1).
			Save(ctx)
		if err != nil {
			fmt.Printf("error while updating event: %s", err)
			if rerr := tx.Rollback(); rerr != nil {
				err = fmt.Errorf("%w: %v", err, rerr)
				return nil, err
			}
			return nil, err
		}
	} else {
		_, err = tx.Event.Update().
			Where(event.ID(eventID)).
			AddConfirmedCount(1).
			Save(ctx)
		if err != nil {
			fmt.Printf("error while updating event: %s", err)
			if rerr := tx.Rollback(); rerr != nil {
				err = fmt.Errorf("%w: %v", err, rerr)
				return nil, err
			}
			return nil, err
		}
	}

	if err := tx.Commit(); err != nil {
		return nil, err
	}

	go func() {
		rows, err := utils.Client.DB().QueryContext(ctx, `
			SELECT d.token FROM event_users eu
			JOIN devices d ON eu.user_id = d.user_id
			WHERE eu.event_id = ? AND eu.admin = true AND eu.confirmed = true;
		`, eventID)
		if err != nil {
			return
		}

		var tokens []string
		affectedRows := 0

		for rows.Next() {
			var token string
			if err := rows.Scan(&token); err != nil {
				log.Printf("Error scanning event_user row: %v", err)
				return
			}

			tokens = append(tokens, token)
			affectedRows++
		}

		if affectedRows == 0 {
			return
		}

		userName, err := r.client.User.Query().
			Where(
				user.ID(*userId),
			).
			Select(user.FieldName).
			String(ctx)
		if err != nil {
			return
		}
		notifications.SendPushNotificationsWithDevices(r.client, tokens, "Happ", userName+" has accepted the invitation for "+thisEvent.Name)

	}()

	if eventUser.Admin {
		return &model.AcceptInvitationResponse{
			CypherText: nil,
			IsHost:     true,
		}, nil
	}

	keyChannel := make(chan awsParameterStore.KeysResGoroutine)
	nonceChannel := make(chan awsParameterStore.KeysResGoroutine)

	go awsParameterStore.GetEventKeyParameterGoroutine("Happ_events_e", keyChannel)
	go awsParameterStore.GetEventKeyParameterGoroutine("Happ_events_o", nonceChannel)

	keyRes, nonceRes := <-keyChannel, <-nonceChannel

	if keyRes.Error != nil {
		fmt.Printf("error while calling getEventKeyParameterGoroutine: %s", err)
		return nil, err
	}

	if nonceRes.Error != nil {
		fmt.Printf("error while calling getEventKeyParameterGoroutine: %s", err)
		return nil, err
	}

	keyBytes, nonceBytes := keyRes.Value, nonceRes.Value

	encryptedKey := thisEvent.EventKey
	encryptedNonce := thisEvent.EventNonce

	decodedEncryptedKey, err := base64.StdEncoding.DecodeString(encryptedKey)
	if err != nil {
		fmt.Printf("error while decoding encrypted key: %s", err)
		return nil, err
	}

	decodedEncryptedNonce, err := base64.StdEncoding.DecodeString(encryptedNonce)
	if err != nil {
		fmt.Printf("error while decoding encrypted nonce: %s", err)
		return nil, err
	}

	decryptedKey, err := AES_Encryption.Decrypt(decodedEncryptedKey, []byte(*keyBytes), []byte(*nonceBytes))
	if err != nil {
		fmt.Printf("error while decrypting key: %s", err)
		return nil, err
	}
	fmt.Println(decryptedKey)

	decryptedNonce, err := AES_Encryption.Decrypt(decodedEncryptedNonce, []byte(*keyBytes), []byte(*nonceBytes))
	if err != nil {
		fmt.Printf("error while decrypting nonce: %s", err)
		return nil, err
	}
	textToBeEncrypted := strconv.Itoa(*userId)

	fmt.Println(textToBeEncrypted)

	cypherTextBytes, err := AES_Encryption.Encrypt([]byte(textToBeEncrypted), decryptedKey, decryptedNonce)
	if err != nil {
		fmt.Printf("error while creating cypher text nonce: %s", err)
		return nil, err
	}

	fmt.Println(cypherTextBytes)

	cypherText := base64.StdEncoding.EncodeToString(cypherTextBytes)

	fmt.Println(cypherText)

	return &model.AcceptInvitationResponse{
		CypherText: &cypherText,
		IsHost:     false,
	}, nil

	// GET FROM DB

	// panic(fmt.Errorf("not implemented"))
}

// UpdateEvent is the resolver for the updateEvent field.
func (r *mutationResolver) UpdateEvent(ctx context.Context, input model.UpdateEventInput, eventID int) (*model.CreateEventResponse, error) {
	userId, authErr := utils.IsAuth(ctx)
	if authErr != nil {
		return nil, authErr
	}

	var errors []*model.ErrorResponse

	eventUser, err := r.client.EventUser.Query().
		Where(
			eventuser.And(
				eventuser.EventID(eventID),
				eventuser.UserID(*userId),
			),
		).
		Only(ctx)
	if err != nil {
		fmt.Printf("error while getting event user: %s", err)
		return nil, err
	}

	if !eventUser.Creator {
		errorMessage := &model.ErrorResponse{
			Field:   "Global",
			Message: "Operation not allowed",
		}
		errors = append(errors, errorMessage)
		return &model.CreateEventResponse{
			Event:  nil,
			Errors: errors,
		}, nil
	}

	event, err := r.client.Event.Query().
		Where(event.ID(eventID)).
		Only(ctx)
	if err != nil {
		return nil, err
	}

	updateEvent := event.Update()

	if input.Name != nil {
		updateEvent = updateEvent.SetName(*input.Name)
	}

	if input.Description != nil {
		updateEvent = updateEvent.SetDescription(*input.Description)
	}

	if input.EventPics != nil {
		var eventPics []string
		var lightEventPics []string

		eventPics = event.EventPics
		lightEventPics = event.LightEventPics

		var objectsToDelete []string

		for _, pic := range input.EventPics {
			index := pic.Index
			action := pic.Action

			if action == "REPLACE" {
				objectsToDelete = append(objectsToDelete, eventPics[index])
				fmt.Println(pic.File)
				content, err := io.ReadAll(pic.File.File)
				if err != nil {
					return nil, fmt.Errorf("could not read picture #%s", strconv.Itoa(index))
				}

				uuid := uuid.New()
				uuidString := uuid.String()
				key := "eventPictures/" + strconv.Itoa(index) + "-" + uuidString + ".jpg"

				eventPics[index] = "https://d3pvchlba3rmqp.cloudfront.net/" + key

				file := bytes.NewReader(content)
				uploadRes := awsS3.UploadToS3(key, file)
				if !uploadRes {
					return nil, fmt.Errorf("could not create event, try again later")
				}
			}
		}

		for _, pic := range input.EventPics {
			index := pic.Index
			action := pic.Action

			if action == "DELETE" {
				objectsToDelete = append(objectsToDelete, eventPics[index])
				eventPics = append(eventPics[:index], eventPics[index+1:]...)
			}
		}

		for _, pic := range input.EventPics {
			action := pic.Action

			if action == "ADD" {
				content, err := io.ReadAll(pic.File.File)
				if err != nil {
					return nil, fmt.Errorf("could not read picture #%s", strconv.Itoa(len(eventPics)))
				}

				uuid := uuid.New()
				uuidString := uuid.String()
				key := "eventPictures/" + strconv.Itoa(len(eventPics)) + "-" + uuidString + ".jpg"

				eventPics = append(eventPics, "https://d3pvchlba3rmqp.cloudfront.net/"+key)

				file := bytes.NewReader(content)
				uploadRes := awsS3.UploadToS3(key, file)
				if !uploadRes {
					return nil, fmt.Errorf("could not create event, try again later")
				}
			}
		}

		for _, pic := range input.EventPicsLight {
			index := pic.Index
			action := pic.Action

			if action == "REPLACE" {
				objectsToDelete = append(objectsToDelete, lightEventPics[index])

				content, err := io.ReadAll(pic.File.File)
				if err != nil {
					return nil, fmt.Errorf("could not read picture #%s", strconv.Itoa(index))
				}

				uuid := uuid.New()
				uuidString := uuid.String()
				key := "lightEventPictures/" + strconv.Itoa(index) + "-" + uuidString + ".jpg"

				lightEventPics[index] = "https://d3pvchlba3rmqp.cloudfront.net/" + key

				file := bytes.NewReader(content)
				uploadRes := awsS3.UploadToS3(key, file)
				if !uploadRes {
					return nil, fmt.Errorf("could not create event, try again later")
				}
			}
		}

		for _, pic := range input.EventPicsLight {
			index := pic.Index
			action := pic.Action

			if action == "DELETE" {
				objectsToDelete = append(objectsToDelete, lightEventPics[index])
				lightEventPics = append(lightEventPics[:index], lightEventPics[index+1:]...)
			}
		}

		for _, pic := range input.EventPicsLight {
			action := pic.Action

			if action == "ADD" {
				content, err := io.ReadAll(pic.File.File)
				if err != nil {
					return nil, fmt.Errorf("could not read picture #%s", strconv.Itoa(len(lightEventPics)))
				}

				uuid := uuid.New()
				uuidString := uuid.String()
				key := "lightEventPictures/" + strconv.Itoa(len(lightEventPics)) + "-" + uuidString + ".jpg"

				lightEventPics = append(lightEventPics, "https://d3pvchlba3rmqp.cloudfront.net/"+key)

				file := bytes.NewReader(content)
				uploadRes := awsS3.UploadToS3(key, file)
				if !uploadRes {
					return nil, fmt.Errorf("could not create event, try again later")
				}
			}
		}

		if len(objectsToDelete) > 0 {

			newObjectKeys := make([]string, len(objectsToDelete))
			for i, objectToDelete := range objectsToDelete {
				objectToDeleteFullString := objectToDelete
				newObjectKeys[i] = strings.ReplaceAll(objectToDeleteFullString, "https://d3pvchlba3rmqp.cloudfront.net/", "")
			}

			deleteEventPicsRes := awsS3.DeleteFromS3(newObjectKeys)
			if !deleteEventPicsRes {
				return nil, fmt.Errorf("could not delete previous image from aws s3")
			}
		}

		updateEvent = updateEvent.SetEventPics(eventPics).SetLightEventPics(lightEventPics)
	}

	if input.Latitude != nil && input.Longitude != nil {
		coords := &schematype.Point{
			*input.Latitude,
			*input.Longitude,
		}

		updateEvent = updateEvent.SetCoords(coords)
	}

	if input.EventPlace != nil {
		updateEvent = updateEvent.SetEventPlace(*input.EventPlace)
	}

	if input.EventDate != nil {
		msInt, _ := strconv.ParseInt(*input.EventDate, 10, 64)
		eventDateTime := time.Unix(0, msInt*int64(time.Millisecond))

		updateEvent = updateEvent.SetEventDate(eventDateTime)
	}

	updatedEvent, err := updateEvent.Save(ctx)
	if err != nil {
		fmt.Println(err)
		// return error could not create event
		return nil, fmt.Errorf("could not create event, try again later")
	}

	fmt.Println(event)

	if input.EventDate != nil || input.EventPlace != nil || (input.Latitude != nil && input.Longitude != nil) {
		go func() {
			rows, err := utils.Client.DB().QueryContext(ctx, `
				SELECT d.token FROM event_users eu
				JOIN devices d ON eu.user_id = d.user_id
				WHERE eu.event_id = ? AND eu.confirmed = true;
			`, eventID)
			if err != nil {
				log.Printf("Error fetching event_users for notifications: %v", err)
				return
			}

			var tokens []string
			affectedRows := 0

			for rows.Next() {
				var token string
				if err := rows.Scan(&token); err != nil {
					log.Printf("Error scanning event_user row: %v", err)
					return
				}

				tokens = append(tokens, token)
				affectedRows++
			}

			if affectedRows == 0 {
				return
			}

			if input.EventDate != nil {
				notifications.SendPushNotificationsWithDevices(r.client, tokens, "Happ", "The date for "+event.Name+" has been changed.")
			}

			if input.EventPlace != nil && (input.Latitude != nil && input.Longitude != nil) {
				notifications.SendPushNotificationsWithDevices(r.client, tokens, "Happ", "The location for "+event.Name+". Check it out!")
			} else {
				if input.EventPlace != nil {
					notifications.SendPushNotificationsWithDevices(r.client, tokens, "Happ", "The location for "+event.Name+". Check it out!")
				}

				if input.Latitude != nil && input.Longitude != nil {
					notifications.SendPushNotificationsWithDevices(r.client, tokens, "Happ", "The location for "+event.Name+". Check it out!")
				}
			}

		}()
	}

	return &model.CreateEventResponse{
		Event: updatedEvent,
		// Errors: &model.ErrorResponse{}[]
	}, nil
}

// DeleteEvent is the resolver for the deleteEvent field.
func (r *mutationResolver) DeleteEvent(ctx context.Context, eventID int) (*bool, error) {
	userId, authErr := utils.IsAuth(ctx)
	if authErr != nil {
		return nil, authErr
	}

	eventUser, err := r.client.EventUser.Query().
		Where(
			eventuser.And(
				eventuser.EventID(eventID),
				eventuser.UserID(*userId),
			),
		).
		Only(ctx)
	if err != nil {
		fmt.Printf("error while getting event user: %s", err)
		return nil, err
	}

	if !eventUser.Creator {
		errorNotAllowed := fmt.Errorf("operation not allowed")
		return nil, errorNotAllowed
	}

	// allGuests, allGuestsErr := r.client.EventUser.Query().
	// 	Where(
	// 		eventuser.EventID(eventID),
	// 	).
	// 	Select(eventuser.FieldUserID).
	// 	Ints(ctx)
	rows, allGuestsErr := utils.Client.DB().QueryContext(ctx, `
		SELECT d.token FROM event_users eu
		JOIN devices d ON eu.user_id = d.user_id
		WHERE eu.event_id = ? AND eu.confirmed = true;
	`, eventID)

	var tokens []string
	affectedRows := 0

	for rows.Next() {
		var token string
		if err := rows.Scan(&token); err != nil {
			log.Printf("Error scanning event_user row: %v", err)
			break
		}

		tokens = append(tokens, token)
		affectedRows++
	}

	var eventName string
	var eventErr error

	if affectedRows > 0 {
		eventName, eventErr = r.client.Event.Query().
			Where(
				event.ID(eventID),
			).
			Select(event.FieldName).
			String(ctx)
	}

	err = r.client.Event.
		DeleteOneID(eventID).
		Exec(ctx)
	if err != nil {
		fmt.Printf("error while deleting th")
		return nil, err
	}

	if allGuestsErr == nil && eventErr == nil && affectedRows > 0 {
		notifications.SendPushNotificationsWithDevices(r.client, tokens, "Happ", eventName+" has been canceled.")
	}

	value := true
	return &value, nil
}

// AddGuests is the resolver for the addGuests field.
func (r *mutationResolver) AddGuests(ctx context.Context, eventID int, userIds []int) (*bool, error) {
	userId, authErr := utils.IsAuth(ctx)
	if authErr != nil {
		return nil, authErr
	}

	var value bool

	eventUser, err := r.client.EventUser.Query().
		Where(
			eventuser.And(
				eventuser.EventID(eventID),
				eventuser.UserID(*userId),
			),
		).
		Only(ctx)
	if err != nil {
		value = false
		return &value, nil
	}

	if !eventUser.Admin {
		return nil, fmt.Errorf("operation not allowed")
	}

	// Add the guests to the event
	bulk := make([]*ent.EventUserCreate, len(userIds))
	for i, userID := range userIds {
		bulk[i] = r.client.EventUser.
			Create().
			SetEventID(eventID).
			SetUserID(userID).
			SetInvitedBy(*userId)
	}

	_, err = r.client.EventUser.CreateBulk(bulk...).Save(ctx)
	if err != nil {
		value = false
		return &value, err
	}

	value = true
	return &value, nil
}

// RemoveGuests is the resolver for the removeGuests field.
func (r *mutationResolver) RemoveGuests(ctx context.Context, eventID int, userIds []int) (*bool, error) {
	userId, authErr := utils.IsAuth(ctx)
	if authErr != nil {
		return nil, authErr
	}

	var value bool

	eventUser, err := r.client.EventUser.Query().
		Where(
			eventuser.And(
				eventuser.EventID(eventID),
				eventuser.UserID(*userId),
			),
		).
		Only(ctx)
	if err != nil {
		value = false
		return &value, err
	}

	if !eventUser.Admin {
		return nil, fmt.Errorf("operation not allowed")
	}

	tx, err := r.client.Tx(ctx)
	if err != nil {
		value = false
		return &value, err
	}

	// Add the guests to the event
	for _, userID := range userIds {
		_, err := tx.EventUser.
			Delete().
			Where(
				eventuser.And(
					eventuser.EventID(eventID),
					eventuser.UserID(userID),
				),
			).
			Exec(ctx)
		if err != nil {
			// tx.Rollback()
			value = false
			if rerr := tx.Rollback(); rerr != nil {
				err = fmt.Errorf("%w: %v", err, rerr)
				return &value, err
			}
			return &value, err
		}
	}

	_, err = tx.Event.Update().
		AddConfirmedCount(-len(userIds)).
		Where(event.ID(eventID)).
		// AddConfirmedHosts(1).
		Save(ctx)
	if err != nil {
		// tx.Rollback()
		fmt.Printf("error while updating event: %s", err)
		value = false
		if rerr := tx.Rollback(); rerr != nil {
			err = fmt.Errorf("%w: %v", err, rerr)
			return &value, err
		}
		return &value, err
	}

	if err := tx.Commit(); err != nil {
		value = false
		return &value, err
	}

	value = true
	return &value, nil
}

// ScanPass is the resolver for the scanPass field.
func (r *mutationResolver) ScanPass(ctx context.Context, eventID int, cypherText string) (*bool, error) {
	var value bool

	event, err := r.client.Event.Query().
		Where(event.ID(eventID)).
		Only(ctx)
	if err != nil {
		return nil, err
	}

	keyChannel := make(chan awsParameterStore.KeysResGoroutine)
	nonceChannel := make(chan awsParameterStore.KeysResGoroutine)

	go awsParameterStore.GetEventKeyParameterGoroutine("Happ_events_e", keyChannel)
	go awsParameterStore.GetEventKeyParameterGoroutine("Happ_events_o", nonceChannel)

	keyRes, nonceRes := <-keyChannel, <-nonceChannel

	if keyRes.Error != nil {
		fmt.Printf("error while calling getEventKeyParameterGoroutine: %s", err)
		return nil, err
	}

	if nonceRes.Error != nil {
		fmt.Printf("error while calling getEventKeyParameterGoroutine: %s", err)
		return nil, err
	}

	keyBytes, nonceBytes := keyRes.Value, nonceRes.Value

	encryptedKey := event.EventKey
	encryptedNonce := event.EventNonce

	decodedEncryptedKey, err := base64.StdEncoding.DecodeString(encryptedKey)
	if err != nil {
		fmt.Printf("error while decoding encrypted key: %s", err)
		return nil, err
	}

	decodedEncryptedNonce, err := base64.StdEncoding.DecodeString(encryptedNonce)
	if err != nil {
		fmt.Printf("error while decoding encrypted nonce: %s", err)
		return nil, err
	}

	decryptedKey, err := AES_Encryption.Decrypt(decodedEncryptedKey, []byte(*keyBytes), []byte(*nonceBytes))
	if err != nil {
		fmt.Printf("error while decrypting key: %s", err)
		value = false
		return &value, err
	}

	decryptedNonce, err := AES_Encryption.Decrypt(decodedEncryptedNonce, []byte(*keyBytes), []byte(*nonceBytes))
	if err != nil {
		fmt.Printf("error while decrypting nonce: %s", err)
		value = false
		return &value, err
	}

	decodedCypherText, err := base64.StdEncoding.DecodeString(cypherText)
	if err != nil {
		fmt.Printf("error while decoding cypher: %s", err)
		return nil, err
	}

	decryptedCypher, err := AES_Encryption.Decrypt(decodedCypherText, decryptedKey, decryptedNonce)
	if err != nil {
		fmt.Printf("error while decrypting cypher: %s", err)
		value = false
		return &value, err
	}

	userIdString := string(decryptedCypher)

	passUserId, _ := strconv.Atoi(userIdString)

	_, err = r.client.EventUser.Query().
		Where(
			eventuser.And(
				eventuser.EventID(eventID),
				eventuser.UserID(passUserId),
			),
		).
		Only(ctx)

	if err != nil {
		fmt.Printf("not on guets list: %s", err)
		value = false
		return &value, nil
	}

	value = true

	return &value, nil
}

// LeaveEvent is the resolver for the leaveEvent field.
func (r *mutationResolver) LeaveEvent(ctx context.Context, eventID int) (*bool, error) {
	userId, err := utils.IsAuth(ctx)
	if err != nil {
		return nil, err
	}

	var value bool

	eventUser, err := r.client.EventUser.Query().
		Where(
			eventuser.And(
				eventuser.EventID(eventID),
				eventuser.UserID(*userId),
			),
		).
		Only(ctx)
	if err != nil {
		fmt.Printf("error while getting event user: %s", err)
		return nil, err
	}

	tx, err := r.client.Tx(ctx)
	if err != nil {
		value = false
		return &value, err
	}

	_, err = tx.EventUser.
		Delete().
		Where(
			eventuser.And(
				eventuser.EventID(eventID),
				eventuser.UserID(*userId),
			),
		).
		Exec(ctx)
	if err != nil {
		fmt.Printf("error while deleting event user")
		if rerr := tx.Rollback(); rerr != nil {
			err = fmt.Errorf("%w: %v", err, rerr)
			return &value, err
		}
		return nil, err
	}

	if eventUser.Admin && eventUser.Confirmed {
		_, err = tx.Event.Update().
			AddConfirmedCount(-1).
			AddConfirmedHosts(-1).
			Where(event.ID(eventID)).
			Save(ctx)
		if err != nil {
			if rerr := tx.Rollback(); rerr != nil {
				err = fmt.Errorf("%w: %v", err, rerr)
				return &value, err
			}
			fmt.Printf("error while updating event: %s", err)
			value = false
			return &value, err
		}
	} else if !eventUser.Admin && eventUser.Confirmed {
		_, err = tx.Event.Update().
			AddConfirmedCount(-1).
			Where(event.ID(eventID)).
			Save(ctx)
		if err != nil {
			if rerr := tx.Rollback(); rerr != nil {
				err = fmt.Errorf("%w: %v", err, rerr)
				return &value, err
			}
			fmt.Printf("error while updating event: %s", err)
			value = false
			return &value, err
		}
	}

	if err := tx.Commit(); err != nil {
		value = false
		return &value, err
	}

	if eventUser.Confirmed {
		go func() {
			rows, err := utils.Client.DB().QueryContext(ctx, `
				SELECT d.token FROM event_users eu
				JOIN devices d ON eu.user_id = d.user_id
				WHERE eu.event_id = ? AND eu.admin = true AND eu.confirmed = true;
			`, eventID)
			if err != nil {
				log.Printf("Error fetching event_users for notifications: %v", err)
				return
			}

			var tokens []string
			affectedRows := 0

			for rows.Next() {
				var token string
				if err := rows.Scan(&token); err != nil {
					log.Printf("Error scanning event_user row: %v", err)
					return
				}

				tokens = append(tokens, token)
				affectedRows++
			}

			if affectedRows == 0 {
				return
			}

			userName, err := r.client.User.Query().
				Where(user.ID(*userId)).
				Select(user.FieldName).
				String(ctx)
			if err != nil {
				log.Printf("Error getting user name: %v", err)
				return
			}

			eventName, err := r.client.Event.Query().
				Where(event.ID(eventID)).
				Select(event.FieldName).
				String(ctx)
			if err != nil {
				log.Printf("Error getting event name: %v", err)
				return
			}

			notifications.SendPushNotificationsWithDevices(r.client, tokens, "Happ", userName+" has leaved "+eventName)
		}()
	}

	value = true

	return &value, nil
}

// SaveDevice is the resolver for the saveDevice field.
func (r *mutationResolver) SaveDevice(ctx context.Context, token string) (*bool, error) {
	userId, err := utils.IsAuth(ctx)
	if err != nil {
		return nil, err
	}

	err = r.client.Device.Create().
		SetUserID(*userId).
		SetToken(token).
		OnConflict().
		SetUserID(*userId).
		Exec(ctx)
	if err != nil {
		return nil, fmt.Errorf("error creating device record")
	}

	value := true
	return &value, nil
}

// User is the resolver for the user field.
func (r *queryResolver) User(ctx context.Context, username string) (*ent.User, error) {
	return r.client.User.Query().Where(user.Username(username)).Only(ctx)
}

// UserFromID is the resolver for the userFromId field.
func (r *queryResolver) UserFromID(ctx context.Context, id int) (*ent.User, error) {
	return r.client.User.Query().Where(user.ID(id)).Only(ctx)
}

// SearchUsers is the resolver for the searchUsers field.
func (r *queryResolver) SearchUsers(ctx context.Context, search string, userSearching int) ([]*ent.User, error) {
	_, err := utils.SaveUserIdInHeader(ctx, userSearching)
	if err != nil {
		return nil, err
	}

	trimmedSearch := strings.TrimSpace(search)

	var users []*ent.User
	res, err := meilisearchUtils.GetUsersFromMeili(trimmedSearch, []int{})
	if err != nil {
		// fmt.Println(res)
		// return nil, err

		// or show empty array of users
		return users, nil
	}

	if len(res) == 0 {
		return users, nil
	}

	for _, user := range res {
		users = append(
			users,
			&ent.User{
				ID:         int(user.(map[string]interface{})["id"].(float64)),
				Username:   user.(map[string]interface{})["username"].(string),
				Name:       user.(map[string]interface{})["name"].(string),
				ProfilePic: user.(map[string]interface{})["profilePic"].(string),
			},
		)
	}

	return users, nil
	// panic(fmt.Errorf("not implemented"))
}

// UserAccess is the resolver for the userAccess field.
func (r *queryResolver) UserAccess(ctx context.Context) (*ent.User, error) {
	userId, err := utils.IsAuth(ctx)
	if err != nil {
		return nil, err
	}

	return r.client.User.Query().Where(user.ID(*userId)).Only(ctx)
}

// GetAllEvents is the resolver for the getAllEvents field.
func (r *queryResolver) GetAllEvents(ctx context.Context) ([]*ent.Event, error) {
	return r.client.Event.Query().Where().All(ctx)
}

// GetAllGuests is the resolver for the getAllGuests field.
func (r *queryResolver) GetAllGuests(ctx context.Context, eventID int) ([]*ent.User, error) {
	eventUsers, err := r.client.EventUser.Query().
		Where(eventuser.EventID(eventID)).
		Select(eventuser.FieldUserID, eventuser.FieldAdmin).
		All(ctx)
		// Strings(ctx)
	if err != nil {
		return nil, err
	}

	fmt.Println(eventUsers)

	// users, err := r.client.User.Query().Where(predicate.User(user.IDIn(eventUsers...))).All(ctx)
	// if err != nil {
	// 	return nil, err
	// }
	// fmt.Println(users)

	// usersMap := make(map[string]ent.User)

	// for _, user := range users {
	// 	usersMap[strconv.Itoa(user.ID)] = *user
	// }

	// for _, id := range eventUsers {

	// 	users = append(
	// 		users,
	// 		&ent.User{
	// 			ID:         int(user.(map[string]interface{})["id"].(float64)),
	// 			Username:   user.(map[string]interface{})["username"].(string),
	// 			Name:       user.(map[string]interface{})["name"].(string),
	// 			ProfilePic: user.(map[string]interface{})["profilePic"].(string),
	// 		},
	// 	)
	// }

	return nil, nil
}

// GetUserEvents is the resolver for the getUserEvents field.
func (r *queryResolver) GetUserEvents(ctx context.Context, limit int, idsList []int) (*model.PaginatedEventResults, error) {
	userId, authErr := utils.IsAuth(ctx)
	if authErr != nil {
		return nil, authErr
	}

	var realLimit int

	if len(idsList) == 0 {
		realLimit = 10
	} else {
		realLimit = 25
	}

	realLimit = limit

	realLimitPlusOne := realLimit + 1

	// var events []*ent.Event
	var eventInvitesRes []*model.EventInviteRes

	var stringIdsList []string

	for _, id := range idsList {
		stringIdsList = append(stringIdsList, strconv.Itoa(id))
	}

	idsListForSQL := ""

	if len(stringIdsList) > 0 {
		idsListForSQL = `where e.id not in (` + strings.Join(stringIdsList[:], ",") + `)`
	}

	res, err := r.client.QueryContext(ctx, `
		select e.*, eu.invited_by, eu.admin, eu.creator from events e

		inner join event_users eu
			on (e.id = eu.event_id)
			and (eu.user_id = `+strconv.Itoa(*userId)+`)
			and (eu.confirmed = true)

		`+idsListForSQL+`

		order by e.event_date ASC
			
		limit `+strconv.Itoa(realLimitPlusOne)+`
	`)

	fmt.Println(err)

	for res.Next() {
		var id int
		var name string
		var description string
		var confirmed_count int
		var event_pics string
		var light_event_pics string
		var event_date time.Time
		var created_at time.Time
		var updated_at time.Time
		var coords schematype.Point
		var invited_by int
		var event_key string
		var event_nonce string
		var confirmed_hosts int
		var admin bool
		var creator bool
		var event_place string

		if err := res.Scan(
			&id,
			&name,
			&description,
			&confirmed_count,
			&event_pics,
			&event_date,
			&coords,
			&created_at,
			&updated_at,
			&light_event_pics,
			&event_key,
			&event_nonce,
			&confirmed_hosts,
			&event_place,
			&invited_by,
			&admin,
			&creator,
		); err != nil {
			// Check for a scan error.
			// Query rows will be closed with defer.
			log.Fatal(err)
		}

		var eventPics []string
		json.Unmarshal([]byte(event_pics), &eventPics)

		var lightEventPics []string
		json.Unmarshal([]byte(light_event_pics), &lightEventPics)

		event := ent.Event{
			ID:             id,
			Name:           name,
			Description:    description,
			ConfirmedCount: confirmed_count,
			ConfirmedHosts: confirmed_hosts,
			EventPics:      eventPics,
			LightEventPics: lightEventPics,
			EventDate:      event_date,
			EventPlace:     event_place,
			Coords:         &coords,
			CreatedAt:      created_at,
			UpdatedAt:      updated_at,
		}

		invitedUserInfo := model.InvitedUserInfo{
			IsConfirmed: true,
			IsHost:      admin,
			IsCreator:   creator,
		}

		eventInviteRes := model.EventInviteRes{
			Event:           &event,
			InvitedByUserID: invited_by,
			InvitedUserInfo: &invitedUserInfo,
		}

		// events = append(events, &event)
		eventInvitesRes = append(eventInvitesRes, &eventInviteRes)
	}

	if len(eventInvitesRes) < realLimit {
		realLimit = len(eventInvitesRes)
	}

	return &model.PaginatedEventResults{
		Events:  eventInvitesRes[0:realLimit],
		HasMore: len(eventInvitesRes) == realLimitPlusOne,
	}, nil

	// return eventInvitesRes, nil
	// select * from events
	// left join
}

// GetUserEventsFromFriends is the resolver for the getUserEventsFromFriends field.
func (r *queryResolver) GetUserEventsFromFriends(ctx context.Context, limit int, idsList []int) (*model.PaginatedEventResults, error) {
	userId, authErr := utils.IsAuth(ctx)
	if authErr != nil {
		return nil, authErr
	}

	realLimit := 8

	realLimit = limit

	realLimitPlusOne := realLimit + 1

	// var events []*ent.Event
	var eventInvitesRes []*model.EventInviteRes

	var stringIdsList []string

	for _, id := range idsList {
		stringIdsList = append(stringIdsList, strconv.Itoa(id))
	}

	idsListForSQL := ""

	if len(stringIdsList) > 0 {
		idsListForSQL = `where e.id not in (` + strings.Join(stringIdsList[:], ",") + `)`
	}

	res, _ := r.client.QueryContext(ctx, `
		select e.*, eu.invited_by, eu.admin, eu.creator from events e

		inner join event_users eu
			on (e.id = eu.event_id)
			and (eu.user_id = `+strconv.Itoa(*userId)+`)
			-- and (eu.creator = false)
			and (eu.confirmed = false)

		inner join follows f
			on (f.user_id = eu.invited_by)
			and (f.follower_id = `+strconv.Itoa(*userId)+`)
			and (f.valid = true)

		`+idsListForSQL+`

		order by eu.created_at DESC

	  limit `+strconv.Itoa(realLimitPlusOne)+`
	`)
	// fmt.Println(err)

	for res.Next() {
		var id int
		var name string
		var description string
		var confirmed_count int
		var event_pics string
		var light_event_pics string
		var event_date time.Time
		var created_at time.Time
		var updated_at time.Time
		var coords schematype.Point
		var invited_by int
		var event_key string
		var event_nonce string
		var confirmed_hosts int
		var admin bool
		var creator bool
		var event_place string

		if err := res.Scan(
			&id,
			&name,
			&description,
			&confirmed_count,
			&event_pics,
			&event_date,
			&coords,
			&created_at,
			&updated_at,
			&light_event_pics,
			&event_key,
			&event_nonce,
			&confirmed_hosts,
			&event_place,
			&invited_by,
			&admin,
			&creator,
		); err != nil {
			// Check for a scan error.
			// Query rows will be closed with defer.
			log.Fatal(err)
		}

		var eventPics []string
		json.Unmarshal([]byte(event_pics), &eventPics)

		var lightEventPics []string
		json.Unmarshal([]byte(light_event_pics), &lightEventPics)

		event := ent.Event{
			ID:             id,
			Name:           name,
			Description:    description,
			ConfirmedCount: confirmed_count,
			ConfirmedHosts: confirmed_hosts,
			EventPics:      eventPics,
			LightEventPics: lightEventPics,
			EventDate:      event_date,
			EventPlace:     event_place,
			Coords:         &coords,
			CreatedAt:      created_at,
			UpdatedAt:      updated_at,
			EventKey:       event_key,
			EventNonce:     event_nonce,
		}

		invitedUserInfo := model.InvitedUserInfo{
			IsConfirmed: false,
			IsHost:      admin,
			IsCreator:   creator,
		}

		eventInviteRes := model.EventInviteRes{
			Event:           &event,
			InvitedByUserID: invited_by,
			InvitedUserInfo: &invitedUserInfo,
		}

		// events = append(events, &event)
		eventInvitesRes = append(eventInvitesRes, &eventInviteRes)
	}

	if len(eventInvitesRes) < realLimit {
		realLimit = len(eventInvitesRes)
	}

	return &model.PaginatedEventResults{
		Events:  eventInvitesRes[0:realLimit],
		HasMore: len(eventInvitesRes) == realLimitPlusOne,
	}, nil

	// return eventInvitesRes, nil
}

// GetUserOtherEvents is the resolver for the getUserOtherEvents field.
func (r *queryResolver) GetUserOtherEvents(ctx context.Context, limit int, idsList []int) (*model.PaginatedEventResults, error) {
	userId, authErr := utils.IsAuth(ctx)
	if authErr != nil {
		return nil, authErr
	}

	realLimit := 8

	realLimit = limit

	realLimitPlusOne := realLimit + 1

	// var events []*ent.Event
	var eventInvitesRes []*model.EventInviteRes

	var stringIdsList []string

	for _, id := range idsList {
		stringIdsList = append(stringIdsList, strconv.Itoa(id))
	}

	idsListForSQL := ""

	if len(stringIdsList) > 0 {
		idsListForSQL = `and e.id not in (` + strings.Join(stringIdsList[:], ",") + `)`
	}

	res, _ := r.client.QueryContext(ctx, `
		select e.*, eu.invited_by, eu.admin, eu.creator from events e

		inner join event_users eu
			on (e.id = eu.event_id)
			and (eu.user_id = `+strconv.Itoa(*userId)+`)
			-- and (eu.creator = false)
			-- and (eu.confirmed = false)

		left join follows f
			on (f.user_id = eu.invited_by)
			and (f.follower_id = `+strconv.Itoa(*userId)+`)

		where (f.user_id is null or f.valid = false)
		`+idsListForSQL+`

		order by eu.created_at DESC
			
		limit `+strconv.Itoa(realLimitPlusOne)+`

	`)

	// fmt.Println(err)

	for res.Next() {
		var id int
		var name string
		var description string
		var confirmed_count int
		var event_pics string
		var light_event_pics string
		var event_date time.Time
		var created_at time.Time
		var updated_at time.Time
		var coords schematype.Point
		var invited_by int
		var event_key string
		var event_nonce string
		var confirmed_hosts int
		var admin bool
		var creator bool
		var event_place string

		if err := res.Scan(
			&id,
			&name,
			&description,
			&confirmed_count,
			&event_pics,
			&event_date,
			&coords,
			&created_at,
			&updated_at,
			&light_event_pics,
			&event_key,
			&event_nonce,
			&confirmed_hosts,
			&event_place,
			&invited_by,
			&admin,
			&creator,
		); err != nil {
			// Check for a scan error.
			// Query rows will be closed with defer.
			log.Fatal(err)
		}

		var eventPics []string
		json.Unmarshal([]byte(event_pics), &eventPics)

		var lightEventPics []string
		json.Unmarshal([]byte(light_event_pics), &lightEventPics)

		event := ent.Event{
			ID:             id,
			Name:           name,
			Description:    description,
			ConfirmedCount: confirmed_count,
			ConfirmedHosts: confirmed_hosts,
			EventPics:      eventPics,
			LightEventPics: lightEventPics,
			EventDate:      event_date,
			EventPlace:     event_place,
			Coords:         &coords,
			CreatedAt:      created_at,
			UpdatedAt:      updated_at,
			EventKey:       event_key,
			EventNonce:     event_nonce,
		}

		invitedUserInfo := model.InvitedUserInfo{
			IsConfirmed: false,
			IsHost:      admin,
			IsCreator:   creator,
		}

		eventInviteRes := model.EventInviteRes{
			Event:           &event,
			InvitedByUserID: invited_by,
			InvitedUserInfo: &invitedUserInfo,
		}

		// events = append(events, &event)
		eventInvitesRes = append(eventInvitesRes, &eventInviteRes)
	}

	if len(eventInvitesRes) < realLimit {
		realLimit = len(eventInvitesRes)
	}

	return &model.PaginatedEventResults{
		Events:  eventInvitesRes[0:realLimit],
		HasMore: len(eventInvitesRes) == realLimitPlusOne,
	}, nil

	// return eventInvitesRes, nil
}

// SeePass is the resolver for the seePass field.
func (r *queryResolver) SeePass(ctx context.Context, eventID int) (*string, error) {
	userId, authErr := utils.IsAuth(ctx)
	if authErr != nil {
		return nil, authErr
	}

	eventUser, err := r.client.EventUser.Query().
		Where(

			eventuser.And(
				eventuser.EventID(eventID),
				eventuser.UserID(*userId),
			),
		).
		Only(ctx)
	if err != nil {
		fmt.Printf("error while getting event user: %s", err)
		return nil, err
	}

	if !eventUser.Confirmed {
		return nil, fmt.Errorf("user has not confirmed")
	}

	event, err := r.client.Event.Query().
		Where(event.ID(eventID)).
		Only(ctx)
	if err != nil {
		return nil, err
	}

	keyChannel := make(chan awsParameterStore.KeysResGoroutine)
	nonceChannel := make(chan awsParameterStore.KeysResGoroutine)

	go awsParameterStore.GetEventKeyParameterGoroutine("Happ_events_e", keyChannel)
	go awsParameterStore.GetEventKeyParameterGoroutine("Happ_events_o", nonceChannel)

	keyRes, nonceRes := <-keyChannel, <-nonceChannel

	if keyRes.Error != nil {
		fmt.Printf("error while calling getEventKeyParameterGoroutine: %s", err)
		return nil, err
	}

	if nonceRes.Error != nil {
		fmt.Printf("error while calling getEventKeyParameterGoroutine: %s", err)
		return nil, err
	}

	keyBytes, nonceBytes := keyRes.Value, nonceRes.Value

	encryptedKey := event.EventKey
	encryptedNonce := event.EventNonce

	decodedEncryptedKey, err := base64.StdEncoding.DecodeString(encryptedKey)
	if err != nil {
		fmt.Printf("error while decoding encrypted key: %s", err)
		return nil, err
	}

	decodedEncryptedNonce, err := base64.StdEncoding.DecodeString(encryptedNonce)
	if err != nil {
		fmt.Printf("error while decoding encrypted nonce: %s", err)
		return nil, err
	}

	decryptedKey, err := AES_Encryption.Decrypt(decodedEncryptedKey, []byte(*keyBytes), []byte(*nonceBytes))
	if err != nil {
		fmt.Printf("error while decrypting key: %s", err)
		return nil, err
	}
	fmt.Println(decryptedKey)

	decryptedNonce, err := AES_Encryption.Decrypt(decodedEncryptedNonce, []byte(*keyBytes), []byte(*nonceBytes))
	if err != nil {
		fmt.Printf("error while decrypting nonce: %s", err)
		return nil, err
	}
	textToBeEncrypted := strconv.Itoa(*userId)

	fmt.Println(textToBeEncrypted)

	cypherTextBytes, err := AES_Encryption.Encrypt([]byte(textToBeEncrypted), decryptedKey, decryptedNonce)
	if err != nil {
		fmt.Printf("error while creating cypher text nonce: %s", err)
		return nil, err
	}

	fmt.Println(cypherTextBytes)

	cypherText := base64.StdEncoding.EncodeToString(cypherTextBytes)

	fmt.Println(cypherText)

	return &cypherText, nil
}

// GetEventGuests is the resolver for the getEventGuests field.
func (r *queryResolver) GetEventGuests(ctx context.Context, eventID int, limit int, idsList []int) (*model.PaginatedEventUsersResults, error) {
	userId, authErr := utils.IsAuth(ctx)
	if authErr != nil {
		return nil, authErr
	}

	var realLimit int

	if len(idsList) == 0 {
		realLimit = 10
	} else {
		realLimit = 25
	}

	realLimit = limit

	realLimitPlusOne := realLimit + 1

	var users []*ent.User

	var stringIdsList []string

	for _, id := range idsList {
		stringIdsList = append(stringIdsList, strconv.Itoa(id))
	}

	idsListForSQL := ""

	if len(stringIdsList) > 0 {
		idsListForSQL = `AND u.id NOT IN (` + strings.Join(stringIdsList[:], ",") + `)`
	}

	res, _ := r.client.QueryContext(ctx, `
		SELECT u.*, f.user_id FROM users u

		INNER JOIN event_users eu ON eu.user_id = u.id AND eu.event_id = `+strconv.Itoa(eventID)+` AND eu.confirmed = true AND eu.admin = false
		LEFT JOIN follows f ON f.user_id = u.id AND f.follower_id = `+strconv.Itoa(*userId)+` AND f.valid = true

		WHERE eu.user_id IS NOT NULL
		`+idsListForSQL+`

		ORDER BY CASE WHEN f.user_id = `+strconv.Itoa(*userId)+` THEN 1 ELSE 2 END, f.user_id DESC

		LIMIT `+strconv.Itoa(realLimitPlusOne)+`;
	`)

	// fmt.Println(err)

	for res.Next() {
		var id int
		var name string
		var username string
		var email string
		var fuid string
		// var birthday time.Time
		// var password string
		var created_at time.Time
		var updated_at time.Time
		var profile_pic string
		var user_id *int

		if err := res.Scan(
			&id,
			&name,
			&username,
			&email,
			// &birthday,
			// &password,
			&created_at,
			&updated_at,
			&profile_pic,
			&fuid,
			&user_id,
		); err != nil {
			// Check for a scan error.
			// Query rows will be closed with defer.
			log.Fatal(err)
		}

		event := ent.User{
			ID:       id,
			Name:     name,
			Username: username,
			Email:    email,
			// Birthday:   birthday,
			// Password:   password,
			CreatedAt:  created_at,
			UpdatedAt:  updated_at,
			ProfilePic: profile_pic,
			FUID:       fuid,
		}

		users = append(users, &event)
	}

	if len(users) < realLimit {
		realLimit = len(users)
	}

	return &model.PaginatedEventUsersResults{
		Users:   users[0:realLimit],
		HasMore: len(users) == realLimitPlusOne,
	}, nil
}

// GetEventHosts is the resolver for the getEventHosts field.
func (r *queryResolver) GetEventHosts(ctx context.Context, eventID int, limit int, idsList []int) (*model.PaginatedEventUsersResults, error) {
	userId, authErr := utils.IsAuth(ctx)
	if authErr != nil {
		return nil, authErr
	}

	var realLimit int

	if len(idsList) == 0 {
		realLimit = 3
	} else {
		realLimit = 25
	}

	realLimitPlusOne := realLimit + 1

	var users []*ent.User

	var stringIdsList []string

	for _, id := range idsList {
		stringIdsList = append(stringIdsList, strconv.Itoa(id))
	}

	idsListForSQL := ""

	if len(stringIdsList) > 0 {
		idsListForSQL = `AND u.id NOT IN (` + strings.Join(stringIdsList[:], ",") + `)`
	}

	res, _ := r.client.QueryContext(ctx, `
		SELECT u.*, f.user_id FROM users u

		INNER JOIN event_users eu ON eu.user_id = u.id AND eu.event_id = `+strconv.Itoa(eventID)+` AND eu.confirmed = true AND eu.admin = true
		LEFT JOIN follows f ON f.user_id = u.id AND f.follower_id = `+strconv.Itoa(*userId)+` AND f.valid = true

		WHERE eu.user_id IS NOT NULL
		`+idsListForSQL+`

		ORDER BY CASE WHEN f.user_id = `+strconv.Itoa(*userId)+` THEN 1 ELSE 2 END, f.user_id DESC

		LIMIT `+strconv.Itoa(realLimit)+`;
	`)

	// fmt.Println(err)

	for res.Next() {
		var id int
		var name string
		var username string
		var email string
		var fuid string
		// var birthday time.Time
		// var password string
		var created_at time.Time
		var updated_at time.Time
		var profile_pic string
		var user_id *int

		if err := res.Scan(
			&id,
			&name,
			&username,
			&email,
			// &birthday,
			// &password,
			&created_at,
			&updated_at,
			&profile_pic,
			&fuid,
			&user_id,
		); err != nil {
			// Check for a scan error.
			// Query rows will be closed with defer.
			log.Fatal(err)
		}

		event := ent.User{
			ID:       id,
			Name:     name,
			Username: username,
			Email:    email,
			// Birthday:   birthday,
			// Password:   password,
			CreatedAt:  created_at,
			UpdatedAt:  updated_at,
			ProfilePic: profile_pic,
			FUID:       fuid,
		}

		users = append(users, &event)
	}

	if len(users) < realLimit {
		realLimit = len(users)
	}

	return &model.PaginatedEventUsersResults{
		Users:   users[0:realLimit],
		HasMore: len(users) == realLimitPlusOne,
	}, nil
}

// SearchForUsersToAddAsGuests is the resolver for the searchForUsersToAddAsGuests field.
func (r *queryResolver) SearchForUsersToAddAsGuests(ctx context.Context, search string, eventID int) ([]*ent.User, error) {
	// Get the list of invited user IDs for the event
	invitedIDs, err := r.client.EventUser.
		Query().
		Where(eventuser.EventID(eventID)).
		Select(eventuser.FieldUserID).
		Ints(ctx)
	if err != nil {
		return nil, err
	}

	trimmedSearch := strings.TrimSpace(search)

	// Search for users using Meilisearch
	var users []*ent.User
	res, err := meilisearchUtils.GetUsersFromMeili(trimmedSearch, invitedIDs)
	if err != nil {
		// return nil, err

		// or show empty array of users
		return users, nil
	}

	if len(res) == 0 {
		return users, nil
	}

	for _, user := range res {
		userMap := user.(map[string]interface{})
		users = append(
			users,
			&ent.User{
				ID:         int(userMap["id"].(float64)),
				Username:   userMap["username"].(string),
				Name:       userMap["name"].(string),
				ProfilePic: userMap["profilePic"].(string),
			},
		)
	}

	return users, nil
}

// FollowState is the resolver for the followState field.
func (r *userResolver) FollowState(ctx context.Context, obj *ent.User) (bool, error) {
	userId, err := utils.GetUserIdFromHeader(ctx)
	if err != nil {
		return true, nil
	}

	if *userId == obj.ID {
		return true, nil
	}

	id := fmt.Sprintf("%s_%s", strconv.Itoa(*userId), strconv.Itoa(obj.ID))

	_, err = meilisearchUtils.GetFollowFromMeili(id)

	if err == nil {
		return true, nil
	}

	return false, nil
}

// CreatedAt is the resolver for the createdAt field.
func (r *userResolver) CreatedAt(ctx context.Context, obj *ent.User) (string, error) {
	createdAtNano := obj.CreatedAt.UnixNano()

	createdAtmillis := createdAtNano / 1000000

	createdAtTime := int(createdAtmillis)

	createdAt := strconv.Itoa(createdAtTime)

	return createdAt, nil
}

// UpdatedAt is the resolver for the updatedAt field.
func (r *userResolver) UpdatedAt(ctx context.Context, obj *ent.User) (string, error) {
	updatedAtNano := obj.UpdatedAt.UnixNano()

	updatedAtmillis := updatedAtNano / 1000000

	updatedAtTime := int(updatedAtmillis)

	updatedAt := strconv.Itoa(updatedAtTime)

	return updatedAt, nil
}

// Event returns generated.EventResolver implementation.
func (r *Resolver) Event() generated.EventResolver { return &eventResolver{r} }

// EventInviteRes returns generated.EventInviteResResolver implementation.
func (r *Resolver) EventInviteRes() generated.EventInviteResResolver {
	return &eventInviteResResolver{r}
}

// Mutation returns generated.MutationResolver implementation.
func (r *Resolver) Mutation() generated.MutationResolver { return &mutationResolver{r} }

// Query returns generated.QueryResolver implementation.
func (r *Resolver) Query() generated.QueryResolver { return &queryResolver{r} }

// User returns generated.UserResolver implementation.
func (r *Resolver) User() generated.UserResolver { return &userResolver{r} }

type eventResolver struct{ *Resolver }
type eventInviteResResolver struct{ *Resolver }
type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
type userResolver struct{ *Resolver }
